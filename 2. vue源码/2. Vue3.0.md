# Vue 3.0

## 一、改写响应式系统

### 1.1 Vue2.x 的响应式系统的缺点
主要体现在追踪数据变化方面：**对于对象**，是遍历对象属性并用 Object.defineProperty 将其转化为 getter 和 setter；**对于数组**，是劫持数组原型方法。

这样做的缺点是：
1. **无法监听数组下标、长度。**
2. **无法检测到对象属性的添加和移除，必须调用特定的 API 才能检测到。**
3. **对于 Map、Set 类型，没有实现数据响应式**。

**拓展问题**：Object.defineProperty 可以将数组下标转化为 getter 和 setter，为什么 Vue2.x 没有这样做？

> 性能问题，Object.defineProperty 需要遍历键名，而如果一个数组长度过长，遍历起来会相对耗时。尤其是长度过长的数组在 js 里很常见，**性能代价和获得的用户收益不成正比**。

### 1.2 Vue3.0 改写的响应式系统
#### 1. 追踪数据变化
给响应式数据创建一个 Proxy 代理对象，劫持数据的方法和属性的 getter、setter。对比于 Vue2.x，有以下优点：
- **不需要对键名进行遍历，因此对数组下标、长度实现了监听。**
- **proxy 可以检测到删除和添加一个对象的属性。**
- **Vue3.0 用 proxy 实现了 Map、Set 类型的响应式。**

#### 2. 依赖收集和触发机制
Vue2.x 用的是 watch 作为依赖，Vue3.0 用的是 effect 作为依赖，两者其实差不多。

不同的地方在于，Vue2.x 是一个 watch 类，向下分支出渲染函数观察者、计算属性观察者、watch 选项观察者三类，不同 watch 之间的特有逻辑公用逻辑往往会耦合在一个函数里，阅读和理解起来比较困难。

而 Vue3.0 则是将这三个观察者的公有部分抽离成一个 effect ，让渲染函数、计算属性、watch 选项去向下调用它，相对而言阅读和理解起来会更简单一点。 

所以，说白了，**是一个自顶向下拓展还是自顶向上拓展的区别**。

#### 3. 异步队列
这个改动不大。都是将触发的依赖先放到一个异步队列并根据 id 去重，然后借助事件循环机制注册一个微任务去延后更新异步队列里的全部依赖。

### 1.3 计算属性的实现
计算属性比较特殊，首先**它作为一个响应式数据可以收集其他 effect 作为依赖**，另外**它作为 effect 依赖也可以被其他响应式数据收集**。

另外，计算属性是一个**惰性求值**的依赖。

所以，当响应式数据改变的时候，会先触发计算属性 effect，但不会立刻执行 effect 对计算属性求值，而是用一个 dirty 布尔变量将计算属性**标记为可重新求值**，然后去触发计算属性自己收集的依赖，这些依赖被触发后，会重新对计算属性进行求值，这个时候，计算属性才会执 effect 去重新求值。

所以，计算属性在响应式系统里扮演的，其实是一个连接响应式数据和 effect的 “**中间桥梁**” 的一个角色。



> [参考博客1](https://github.com/cangshudada/vue3.0-reactivity-analyze)
> [参考博客2](https://www.jianshu.com/p/ced3764ee87a)
