# Vue2.6 概要分析
## 一、流程问题
#### 1.1 new Vue 初始化一个实例，中间干了什么
Vue 2.6 的构造函数其实只执行了一个 init 函数来初始化一个实例，这个 init 函数执行的主要内容如下：
1. **预处理开发者传入的各种选项**，并指定一个 vue 实例的内部属性 options (vm.$options) 去访问这些选项，为后续的初始化工作做准备。比如，props 选项其实有三种写法，预处理选项的时候就会把这三种写法统一成一种写法。
2. **真正地去处理 options 选项。里面最重要的一步是对 props、data、computed 等进行响应式观测**。有一个细节可以注意，是先初始化 props，再初始化 data，然后再初始化 computed 的，所以 data 可以用 props 来定义，computed 可以用 props、data 来定义。
3. **执行 vm.$mount 方法，将 vue 实例的数据挂载到真实的 DOM 上。模板编译，beforeMount 钩子，定义渲染函数，并创建渲染函数的观察者，mounted 钩子**（创建渲染函数观察者的时候会执行一次渲染函数，所以页面也就被渲染出来了）

#### 1.2 Vue 的每一个生命周期前干了什么
1. **beforeCreate：对 vue 实例的可观测选项进行响应式观测前**
2. **created：对 vue 实例的可观测选项进行响应式观测后** 
3. **beforeMount：模板编译后，定义渲染函数前**
4. **mounted：创建渲染函数观察者后，也就是第一次执行渲染函数后**
5. **beforeUpdate：渲染函数观察者被触发之后，渲染函数执行之前**
6. **updated：渲染函数观察者被触发并执行完渲染函数后**
7. **beforeDestroy：实例销毁 (vue 实例的全部观察者被卸载，从页面移除对应 DOM 节点) 之前**
8. **destroyed：实例销毁之后**
## 二、数据响应系统
### 2.1 数据响应系统原理（自己实现一个数据响应系统）
1. **如何追踪到一个数据它发生了变化？**
> 答：在 Vue2.6 里，**追踪一个对象的变化，是将它的属性全部转化为 getter 和 setter，而追踪一个数组的变化，是通过代理数组原型上的方法来实现**。 
2. **定义观察者**
> 答：什么是观察者呢，**观察者可以理解为数据响应系统的具体应用**。Vue 里面有三种观察者：渲染函数观察者、计算属性观察者、wather 选项里的观察者。
> 
> **观察者的作用可以分两步：1. 读取响应式数据被 getter 收集为依赖。2. 修改响应式数据时被 setter 触发**。
>
> 以渲染函数观察者举例：
> 1. 收集依赖：创建渲染函数观察者，会执行一次渲染函数，所以会对渲染函数里依赖的响应式数据进行求值，然后会触发这些响应式数据的 getter，getter 会将渲染函数观察者收集到 dep 里作为依赖。
> 2. 触发依赖：当响应式数据改变的时候，会触发 dep 里收集到的渲染函数观察者，渲染函数观察者被触发后会重新执行一次渲染函数来重新渲染页面。
3. **异步更新队列**
> 答：假设有一个响应式数据，它收集了渲染函数观察者作为依赖。如果我在一段代码里多次改变它的值，它的 setter 也会反复触发渲染函数观察者。如果每一次触发，都要执行一次渲染函数，那么 DOM 更新的消耗就很大。
>
> 所以可以**维护这样一个异步队列，观察者被触发后就会被放入异步队列待执行，多次触发只被放入一次。然后注册一个微任务，用来专门处理异步队列里的观察者**。
>
> 所以哪怕渲染函数观察者被连续多次触发，最后也只会执行一次渲染函数，大大节省了渲染性能。

### 2.2 Vue2.0 做不到观察数组下标，是真的做不到还是？
Object.defineProperty 其实是可以对数组下标进行观察的。至于为什么不这样子做，尤雨溪回答说：**性能问题，对数组下标进行观测的性能代价和获得的用户收益不成正比**。Vue2.0 对象属性进行观测时，需要遍历键名，一个对象的键名一般都不多。但长度上千上万的数组很常见，对它们进行遍历观测时的成本太高。

### 2.3 Vue2.0 能否观察 Map 或者 Set 类型的数据？
Vue 2.6 是不可以的，Vue 3.0 通过 proxy 代理实现了对这两种数据结构的观测。

### 2.4 Vue是如何处理 Computed 属性的？
1. **计算属性本质是一个观察者**
> 它本质是一个观察者，但作为观察者它和其他观察者有一个关键区别：**惰性求值。它被触发的时候不会重新计算表达式，而是会等到下次被 getter 求值的时候才会重新求值**。所以哪怕它依赖的响应式数据改变了很多次，它的 getter 一次也不会执行，除非你真的访问了它调用了它的 getter。

2. **计算属性的应用场景是作为响应式数据和观察者的中间桥梁**
> 计算属性比较特殊，首先它和普通属性一样，可以拥有 getter 和 setter 来收集依赖和触发依赖，同时它本身也是一个观察者，可以做为依赖被触发和更新。所以，它**实际应用场景更多是被设计为响应式数据和其他观察者的中间桥梁的**。
>
> 举个例子，假设**模板里面用到了计算属性，而计算属性里面用到了响应式数据**。
> 
> 那么，**收集依赖的时候，其实是让响应式数据把计算属性观察者和渲染函数观察者都收集起来作为依赖**。
>
> 然后，触发依赖的时候，**先触发计算属性观察者**，因为计算属性观察者是惰性求值所以**不会立刻重新计算**，然后**再触发渲染函数观察者**，重新执行渲染函数，重新对计算属性进行求值，这个时候计算属性才被真正重新计算。

### 2.5 Vue最后处理成为观察者有哪几种选项？如果同时被触发，同一个组件内部，这几种观察者的执行顺序是怎么样的？为什么呢？
**观察者有三种，执行顺序是：计算属性观察者 → watch 选项观察者 → 渲染函数观察者**

**观察者的执行顺序其实是按照它们的创建顺序排序的**。创建一个 vue 实例的时候，是**先处理计算属性选项，再处理 watch 选项，最后生成渲染函数观察者**。创建观察者的时候，通过全局的一个自增 id 作为观察者的 id，这样子观察者的创建顺序就可以通过 id 大小反映出来。

具体的话，就是**处理异步队列里的观察者时，先把它们按 id 排序，再按顺序执行**。

为什么要这样设计呢？其实是一个依赖优先级的关系。watch 里可能访问计算属性，所以它需要计算属性的最新状态。而渲染需要什么，需要全部响应式数据的最新状态，所以渲染需要放到最后执行。

### 2.6 异步队列利用了什么原理，为什么要使用异步队列？
异步队列：将在主线程里被触发的观察者放入异步队列，然后注册一个微任务来处理异步队列的观察者。（用到的是事件循环原理）

假如一个响应式数据收集了渲染函数观察者作为依赖。然后在一段代码里我反复改变这个响应式数据，那么渲染函数观察者会被多次触发。如果每一次触发都执行一次渲染函数，那么页面的 DOM 操作消耗是巨大且浪费的。

所以维护这样一个异步队列，将需要触发的观察者放入其中待执行，**多次触发只放入一次**，最后通过一个注册的微任务来来处理这些观察者，很大程度上减少了观察者的更新次数，尤其是渲染函数观察者。

## 三、Virtual DOM
### 3.1 Vnode 的意义
1. 跨平台
2. DOM 操作要比 js 计算慢得多，用 js 计算性能换取 DOM 操作性能
3. 通过 diff 算法减少 DOM 操作，最大程度地去复用一些节点

### 3.2 说一下异步组件的加载过程
**普通组件的渲染**：

1. 获取构造函数
2. 用构造函数生成 vnode
3. 用 vnode 来 petch 渲染

**异步组件和普通的组件的区别在于它需要渲染两次：**

1. 第一次渲染的时候，执行加载组件资源的异步函数，因为是异步加载所以暂时还拿到构造函数，只能**先返回一个占位的空 vnode** 用以 petch 渲染
2. 第二次渲染，是因为**给加载组件资源的异步函数指定了回调**。组件加载完毕后会执行回调，回调会用加载到组件资源生成组件的构造函数，然后**调用父组件的 forceUpdate 方法让父组件重新渲染**，父组件重新渲染就会触发异步组件重新渲染。因为这时候组件已经加载完毕，所以就可以用组件创造函数生成真实的 vnode 来 petch 渲染，并把第一次渲染的占位的 vnode 顶替掉。

### 3.3 说一下 diff 算法
1. 什么是 diff 算法
> diff 算法就是**用新旧 vnode 进行 petch 打补丁的时候**用的算法。 
2. 它的具体
> 它的具体内容很多，其中最关键的一步是判断新旧 vnode 值不值得比较。什么叫值得比较呢，就是新旧 vnode 的 key 一样，标签一样，如果是 input 的话它们的 type 一样……，换句话说新旧 vnode 描述的是否是同一个 DOM 节点，是的话用新 vnode 更新旧 vnode，不是的话以新 vnod 去替换旧 vnode。
> 
> 如果是用新 vnode 更新旧 vnode，那么最关键的一步就是**比较它们的子节点列表**，尤其是对于 v-for 渲染的子节点列表而言，这也是 **diff 算法的最核心部分**。
> 
> **对于 v-for 子节点而言，它们的区别在于 key**。
> 
> 在更新子节点 vnode 的时候，首先进行双端比较，双端比较失败后会用旧 vnode 列表的 key 和 下标建立一个哈希表。**双端比较和哈希表的本质都是用相同 key，去找到描述同一个 DOM 节点的新旧 vnod**e，对他们进行 petch 更新，更新完后再以新 vnode 的位置为基准去移动 DOM 节点的位置。
> 
> 因为新旧 vnode 的相同 key 关系，可以进行最大程度的 DOM 节点的复用。
3. 它的作用 
> 减少没必要的 DOM 操作，最大程度地去复用一些节点。

### 3.4 说一下 diff 算法里的 key，以及使用全局唯一 id 作为 key 和 index 作为 key 的区别
> diff 算法里面的 key，其实是优化 v-for 子节点列表渲染的。
> 
> 对于 v-for 子节点而言，它们用的相同模板，所以**只能用 key 进行区分**。而我们指定 key 有三种方法：不指定、用 index 当 key，用唯一 id 当 key。
> 
> 如果指定 index 当 key，那么跟不指定是没区别的。因为对于新旧 vnode 而言，**相同 key 只代表相同的下标，而不代表它们原本描述的是同一个节点**。所以无法进行节点复用，只能按照相同下标来一一对比更新 petch。
>
> 如果指定 唯一 id 当 key，不管 v-for 数组的顺序怎么打乱，**新旧 vnode 总能通过相同的 key 进行一一匹配**更新，然后通过 DOM 的 insetBefore 调整节点位置，达到节点的复用。
> 
> 具体有什么差别呢，举个例子：比如我将 v-for 的那个数组的头元素移动到末尾。如果我用 index 为 key，那么它可能会把整个子节点都重新修改一次；而如果我用唯一 id 作为 key，它只会执行一次 insertBefore 来讲首子节点移动到末尾。

### 3.5 如果一个组件的 key 是动态的，那么 key 改变时会发生什么事情？ 比如 `<A key="1"/>` → `<A key="2"/>`
因为 key 不同，sameNode(vnode, oldVnode) 会判断它们描述的不是同一个 DOM 节点，所以 **DOM 节点无法复用**，key 为 1 的 A 会被移除，key 为 2 的 A 会被创造出来并替换原本的 A。
> ps：题目有点问题，没说同级元素里是否还有 key 为 1 和 2 的，那我默认是没有的。如果有的话，则是新旧 vnode 里 key 为 1 的两者进行 petch 更新，key 为 2 的两者进行 petch 更新。**总之，key 改变后，从 vnode 的角度看，这两个 DOM 节点已经不是同一个 DOM 了。**

## 四、模板编译
### 4.1 模板编译的过程
1. 执行 parseHtml 一点一点解析模板字符串，生成 AST 语法树
2. 用 AST 语法树执行 generate 函数来生成目标平台的代码
3. 通过 new Function (目标平台代码) 来生成 render 函数
## 五、事件系统

### 5.1 在模板定义一个事件，从编译处理，到组件实例监听的过程是长什么样子的？
Vue 的事件分两类：**原生事件和自定义事件**。

**在模板的元素节点上定义的，都是原生事件：**
1. 编译 → 把事件名和事件处理程序建立键值对，放到一个 `data.on` 里
2. render → 这个 data 会作为 `vnode.data`
3. petch → 执行 create 钩子，调用平台化方法把 `vnode.data.on` 里的事件绑定到 `vnode.elm` 上

在模板使用组件时，在**组件上定义的事件，默认是自定义事件，有 .native 修饰符的是原生事件**：
1. 编译时 → 事件名和事件处理程序建立键值对，原生事件放到 data.nativeOn 里，自定义事件放到 data.on 里
2. render 时 → 将自定义事件抽离到组件选项（vnode.componentOptions.listeners）里，原生事件重新放到 `data.on` 里。
3. petch 时 → **首先会初始化组件实例**，初始化的时会执行 initEvnets 函数把组件选项（vm.$options._parentListeners）里的自定义事件全部挂载的组件实例上。实例创建完了，会**执行 create 钩子**，把 `data.on` 里原生事件全部绑定到 `vnode.elm` 也就是组件根节点上。


### 5.2 Vue 的组件通信方式 (六种)
#### 1. props 和 $emit
父组件通过指定子组件的 prop 来传递数据，子组件通过 $emit 触发自定义事件给父组件传递数据。

应用场景：简单的**父子组件**通信。

#### 2. $parent / $children 与 ref
`ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例

`$parent` / `$children`：访问父 / 子实例

通过 $parent / $children 与 ref 可以访问父子组件实例，通过访问和调用实例上的属性和方法来实现组件通信。

应用场景：**父子组件**通信。

#### 3. $attrs 和 $listeners
`$attrs`：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。

`$listeners`：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件

总结： props 和 $emit 可以实现父子组件通信，而结合 $attrs 和 $listeners 后可以实现跨级组件通信。所以  $attrs 和 $listeners  可以理解为 props 和 $emit 的拓展补充。

应用场景：**父子、跨级组件**的通信。

#### 4. provide 和 inject
祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。需要注意的是，provide 和 inject 绑定并不是可响应的。

应用场景：**父子、跨级组件**间的通信，不过更多是子组件获取上级组件的状态。

#### 5. 事件总线 Bus（$emit / $on）
通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括**父子、兄弟、跨级**。

应用场景：项目较大时比较难维护，所以比较适合中小型项目里任意组件的通信。

#### 6. vuex
Vuex 通过给全局提供 State 和修改 State 的 Mutation、Action 来实现**父子、兄弟、跨级**组件通信，另外说多一句 Vuex 的单向数据流（Action 操作 → Mutation 操作 → 修改 State → 视图改变）

应用场景：适应于较大型项目的任意组件通信。因为 vuex 其实 new 了一个新的 vue 实例，还有对 State 里的数据进行了响应式处理，所以对于小型项目来说有点大材小用。




