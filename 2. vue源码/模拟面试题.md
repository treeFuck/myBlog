# 模拟面试题

## 八、Vue + Vuex + VueRouter
### 8.1 说一下 vue 组件通信方式

1. props 和 $emit 进行父子组件通信：父组件通过 props 传递数据到子组件，子组件通过 emit 触发父组件给子组件指定的自定义事件。
2. vue 实例上的 $children、$parent、ref 去访问组件的父子组件，然后可以访问 vue 实例上的 data、方法这些，进而来父子组件通信
3. provide 和 inject：祖先组件通过 provide 提供变量，子孙组件通过 inject 来注入变量，实现跨级组件的通信，不过 provide 和 inject 注入的变量都不是响应式的。
4. $attr 和 $listener：$attr 里面是，没有被子组件识别的 prop，可以继续注入到子组件的子组件里去。$listener 则是父组件给子组件注册的自定义事件，可以记住注入到子组件的子组件里去。进而实现跨级通信。
5. 事件总线。全局维护一个空的 vue 实例，用来注册事件和触发事件，其他组件通过使用事件总线的事件流来进行通信，可以实现父子、跨级、兄弟组件通信。不过，当项目大型起来，事件总线就很难维护了，所以事件总线比较适合小型项目
6. Vuex。Vuex 本质也是创建一个 vue 实例，用来将 state 处理成响应式的。vuex 有一个单向数据流的规范，用以方便梳理状态修改的来源。vuex 适合一些中大型项目，对于小型项目而言有点大材小用。

### 8.2 说一下 Vuex 原理（让你设计一个 Vuex 你怎么设计）

1. Vuex 的数据响应式
   Vuex 的 state 和 getter 是响应式的，本质其实创建了一个新的 vue 实例，将 state 作为 data 选项，而 getter 作为计算属性选项来处理，进而去实现两者的响应式，和 vue 项目里的数据响应式进行统一。
2. Vuex 的单向数据流
   Vuex 有一个单向数据流的书写规范，就是 state 只能通过同步的 mutation 去修改，异步的 action 只能调用同步的 mutation 去修改 state，而页面则只能通过调用异步的 action 或者同步的 mutation 去修改 state 来改变视图。维护这样一个单向数据流，是有利于追踪到数据改变的调用，让 state 的修改变得可预测。

### 8.3 说一下 Vuex 的单向数据流

Vuex 有一个单向数据流的书写规范，就是 state 只能通过同步的 mutation 去修改，异步的 action 只能调用同步的 mutation 去修改 state，而页面则只能通过调用异步的 action 或者同步的 mutation 去修改 state 来改变视图。维护这样一个单向数据流，是有利于追踪到数据改变的调用，让 state 的修改变得可预测。

### 8.4 说一下 Vue-Router 原理 （让你设计一个 Vue-Router 你怎么设计）
1. 路由匹配机制
   创建 vue-router 对象的时候，会创建一个匹配器，用来匹配路由对应的组件。本质是将路由指定的路径编译成正则表达式，和当前的路由路径进行正则匹配，将匹配成功的路由组件返回用以渲染。
2. 路由组件的渲染机制
   vue-router 内部维护了一个 route 对象，这个对象是一个响应式数据，并收集了渲染函数作为观察者。一旦路由发生修改，route 也会跟着改变，然后就可以触发渲染函数观察者重新渲染新的路由组件。

### 8.5 Vuex-Router 有几种路由，他们有什么差别

### 8.6 说一下 Vue 响应式系统，让你设计的话你怎么设计

Vue 的响应式系统分为三个部分：

1. 追踪数据变化。
2. 观察者 → 收集观察者和触发观察者
3. 异步队列 → 去重

### 8.7 Vue3.0 的响应式系统和 Vue2.x 的响应式系统有什么区别

### 8.8 说一下 Vue 的模板编译

### 8.9 说一下虚拟 DOM 的意义

1. 跨平台。不同的平台下的渲染层实现可能不同，但是可以向上抽离成相同的 vnode 描述，向下再兼容不同的平台渲染方法，实现跨平台的开发。
2. 用 js 计算性能换取 DOM 操作性能。我们知道 DOM 操作是比较消耗性能的，通过 diff 算法来计算出尽可能少的 DOM 操作，避免不必要的 DOM 操作，当然这个 diff 算法计算出的 DOM 操作有时候可能也不是最优的。

### 8.10 说一下 Vue 的 diff 算法

diff 算法，是 vue 使用新旧 vnode 进行 petch 打补丁时使用的。

petch 对比的前提是，新旧 vnode 描述的是同一个 DOM 节点，什么叫描述同一个 DOM 节点呢，就是新旧 vnode 的 key 一样、标签一样、如果是 input 标签的话它们的 type 一样等等。如果新旧 vnode 描述的不是同一个 vnode 了，那么直接移除旧的 DOM，用新 vnode 生成新的 DOM 插入到条页面里去。

如果描述的是同一个 DOM，那么就会去更新它的属性啊、样式啊、事件的这些。最关键的，是更新子节点列表，这也是 diff 算法的核心。

更新子节点列表时，首先使用双端比较，就是判断新旧子节点 vnode 双端是否描述同一个 DOM，如果是的话，则可以复用 DOM 节点。双端比较失败后，会使用旧子节点 vnode 列表的 key 和数组下标创建一个哈希表，本质也是给新子节点 vnode 来判断是否存在可以复用的旧 vnode，以减少 DOM 操作。

特别是对于 v-for 子节点而言，子节点使用的都是同一个模板，区别只在于 key。

一旦使用 index 为 key，那么每次更新 v-for 都会按照下标来进行 petch 更新。这种是使用场景是列表的页码切换。

如果使用唯一 id 作为 key，那么更新 v-for 数组时，会使用 key 来进行最大程度的 DOM 节点复用。比如 v-for 数组只是将头元素放到了末尾，那么双端比较就可以判断出来，只调用一次 insertBefore 去修改 DOM 位置，其他的节点全部可以复用。这种情况适合对同一个列表进行多种排序时使用，比如将同一份成绩列举从大到小排序切换到按班级排序。

### 8.11 MVC 和 MVVM

MVC 模式，model-view-controller。model 就是数据，view 就是界面，controller 就是逻辑层，负责 model 和 view 之间的数据传递，也就是：

1. 将数据 model 显示在 view 界面上，比如 DOM 操作
2. 从 view 界面上来获取 model 数据，比如 DOM 的事件

但 controller 层不仅仅负责 model 层和 view 层的数据交互，它还有其他很多的业务逻辑，所以 controller 会显得比较臃肿。

所以，提出了 MVVM 模式，将 model 和 view 的间接通信工作抽离了出来，这部分叫 VM。比如 Vue 框架，就是一个典型的 MVVM 框架，将数据修改到 DOM 的更新这部分工作单独抽离出来，作为 VM，这样开发者就不用关心 model 层和 view 层的映射过程，只需要关心对数据的业务逻辑部分。

### 8.12 计算属性的实现

vue 里计算属性比较特殊，它既是一个响应式数据可以收集其他观察者为依赖，同时它也是一个观察者可以被其他响应式数据收集。

当计算属性依赖的响应式数据修改时，会触发计算属性观察者，但是计算属性不会立刻重新求值，而是将自己标记为是需要重新求值的，然后，它会去触发它自己收集的观察者，这些观察者被触发后，会进行更新，然后重新对计算属性求值，这时候计算属性才会开始重新求值。