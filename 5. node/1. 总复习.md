# Node

## 一、NPM

### 1.1 package 包
包是模块的一种组织方式。

包的结构目录如下：
1. package.json：包描述文件
2. bin：存放可执行二进制文件的目录
3. lib：存放 js 代码的目录
4. doc：存放文档的目录
5. test：存放单元测试用例代码的目录

### 1.2 包描述文件 package.json
```json
{
	name: 包名,
	version: 版本号,
    description: 包简介,
    licenses: 当前包所使用的许可证列表,
	repositories: 托管源代码的位置列表，
    dependencies: 该包依赖的其他包列表,
	devDependencies: 该包开发时才依赖的其他包列表,
    scripts: 脚本说明对象，主要被包管理器用来安装、编译、测试、卸载包，
    main: 该包被 require 引入时，会以该字段指定的文件作为模块入口。默认是 index.js,
	maintainer: 包维护者列表,
	contributors: 贡献值列表,
	bin: 将包作为命令行工具使用时的配置,
    bugs: 反馈 bug 的网络地址 / 邮箱地址,
    keywords: 关键词数组，npm 会用这个字段来进行分类搜索
}
```
### 1.3 npm 常用功能
npm 可以对安装、卸载、管理依赖包。


## 二、异步 I/O
### 2.1 为什么要异步 I/O
1. I/O 本身是昂贵的
2. 单线程阻塞，导致 CPU 性能不能很好被利用；而多线程虽然能更好利用多核 CPU，但是多线程难以管理，经常伴随线程死锁、状态同步的问题。

所以，提出了异步 I/O 模型

### 2.2 什么是异步 I/O
js 运行在单线程，I/O 操作通过异步执行，异步 I/O 执行完毕后通过事件循环执行 I/O 回调。

js 虽然执行在单线程里，但是 I/O 的底层是多线程的，只是 I/O 线程使用的 CPU 较少。
#### 2.2.1 阻塞 I/O与非阻塞 I/O
异步 I/O 所说的异步，是在单线程 js 上调用的 I/O api 是异步的。
但对于操作系统内核里的 I/O 操作，只有两种方式：阻塞与非阻塞。

阻塞 I/O 会造成 CPU 等待 I/O 的完成，浪费 CPU 性能。
非阻塞 I/O 需要不断轮询去确认 I/O 的完成，轮询本身会浪费 CPU 性能。

所以，不管是阻塞 I/O 还是非阻塞 I/O ，都不能很好实现异步 I/O。要想实现异步 I/O，我们可以将场景拓展到多线程的情况下：
1. 一个线程处理计算任务，发起异步 I/O 调用
2. 其他多个线程进行阻塞/非阻塞 I/O 操作，将 I/O 结果通过线程通信传递给计算线程

Node 的异步 I/O 采用的就是这种模式，js 运行在单线程里，而 js 线程发起的 I/O 操作本质由 node 内部维护的 I/O 线程池去处理。

> 异步 I/O 的 I/O 操作在不同平台有不同的实现。在 \*nix 平台下是自定义的 I/O 线程池，而在 Window 平台下是 IOCP，IOCP 的内部其实仍是线程池原理。二者通过 libuv 作为兼容封装层向上提供异步 I/O api。

### 2.3 异步 I/O 的缺点
Node 适合搭建密集 I/O 型后端，不适合搭建 CPU 密集型后台。

因为 node 里通过异步 I/O 可以处理高并发的 I/O 请求，但是的计算任务只会在 js 单线程里进行，无法充分里 CPU 的多线程计算性能，不适合 CPU 密集型。

当然，node 可以通过开辟子线程来分离计算任务，但是治标不治本，在 CPU 密集型上仍旧比不过多线程后台的处理性能。


### 2.4 事件循环
异步 I/O 的 I/O 操作完毕后，回将异步回调通过事件循环返回到 js 线程里执行。所以，事件循环也是异步 I/O 至关重要的一环。

node 事件循环处理顺序和浏览器不同，宏任务处理分为以下 6 个阶段：
1. **timer 阶段 → 处理定时器回调**
2. pending callback 阶段 → 处理延迟到下一循环的异步 I/O 回调
3. idle，prepare 阶段 → 系统内部使用
4. **poll 阶段 → 处理异步 I/O 回调**
5. **check 阶段 → 处理 setImmediate 的回调**
6. check callback  → 一些关闭的回调函数，如 socket.on('close', ()=>{})

而且和浏览器事件循环一次 tick 处理一个宏任务不同，node 事件循环一次 tick 会执行全部的宏任务。



那么微任务呢？首先，微任务队列分两类：

1. **先处理全部 process.nextTick 指定的微任务**
2. **后处理全部 promise 的 then 指定的微任务**

微任务的执行时机，一般是一个宏任务执行阶段的末尾。不过有一个阶段比较特殊，就是 poll 轮询阶段，它是执行一个宏任务清空一次微任务队列。


## 三、内存控制

### 3.1 V8 的垃圾回收机制与内存限制
#### 3.1.1 V8 的内存限制
一般的后端语言在内存使用上没有什么限制，但是 Node 中 js 的执行是基于 V8 引擎，V8 引擎限制了 js 能使用的内存上限（64 位系统下是 1.4 GB，32 位系统下是 0.7 GB）

这个 V8 的内存限制，和其垃圾回收机制有关。

因为垃圾回收会引起 js 线程的暂停，为了避免过度阻塞 js 线程，需要提高垃圾回收速度。而垃圾回收的耗时和使用的内存空间有直接关系，所以 V8 简单粗暴地选择限制内存空间使用上限。

#### 3.1.2 V8 的垃圾回收
V8 里，原始值（基本类型值）是分配在栈内存的，而引用值是分配到堆内存的。

V8 里堆内存的垃圾回收策略主要基于分代式垃圾回收机制。V8 将堆内存分为新生代和老生代：
1. 新生代对象 → 存活时间较短的对象
2. 老生代对象 → 存活时间较长或常驻内存的对象

> 比如局部变量引用的对象，它们存活周期比较短，就是新生代对象。
>
> 而又比如全局变量引用的对象，直到进程退出才会被回收，存活周期比较长，属于老生代对象。还有一些闭包引用的对象，它们在函数执行完毕后不会被立即销毁，也属于老生代对象。

##### 1. 新生代对象垃圾回收算法——Scavenge（GC 复制算法）
将堆内存一分为二，一个叫 From 空间，另一个叫 To 空间：
1. 分配对象内存时，只分配在 From 空间里。
2. 进行垃圾回收时，将 From 空间里的存活对象复制到 To 空间，From 空间剩下的就是非存活对象，释放它们占用的内存空间。
3. 完成复制后，From 空间和 To 空间角色调换。

##### 2. 老生代对象垃圾回收算法——Mark-Sweep & Mark-Compact（标记清除 & 标记整理）
Mark-Sweep 分标记和清除两个阶段：
1. 遍历堆里对象，标记依旧存活的对象
2. 清除没有被标记的对象

Mark-Sweep 最大的问题在于，一次标记清除后，内存空间会出现不连续的情况。 这时旧需要 Mark-Compact 标记整理算法，移动存活对象的内存空间以得到连续的可用内存空间。

### 3.2 堆外内存
node 的内存不是完全由 V8 分配的，还有一部分不是通过 V8 分配的，这部分叫堆外内存，不收 V8 垃圾回收机制管理。比如 Buffer 对象。

为何 Buffer 对象并非通过 V8 分配？
> 这在于 Node 并不同于浏览器的应用场景。在浏览器中，JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 I/O 流，操作字符串远远不能满足传输的性能需求。

## 四、Buffer 对象
一般在浏览器中，js 能够操作的数据流一般是字符串形式，并且很少涉及到网络和文件 I/O。而在 Node 里，网络和文件 I/O 的场景比较常见，如果通过字符串进行 I/O 操作性能方面跟不上需求，所以我们需要 node 能处理二进制文件，因此 Buffer 对象应运而生。

Buffer 对象是一个类似 Array 的对象，有长度，可以通过下标读写元素。
```js
let buf = new Buffer('str', 'utf-8');
console.log(buf[2]);
```
### 4.1 buffer 内存分配
之前提过，buffer 属于堆歪内存，所以它的内存分配不依赖 V8。buffer 的内存其实是在 C++ 层面上实现内存分配的。

### 4.2 buffer 的转换
buffer 对象与字符串之间可以相互转换，转换需要指定字符串编码，不指定默认 'utf-8'。
```js
let buf = new Buffer('aaaaa', 'utf-8'); // 字符串 → buffer
buf.toString('utf-8'，0，buf.length-1); // buffer → 字符串
```
### 4.3 buffer 的拼接
Buffer 在使用场景中，一般是通过一段一段的方式进行传输，比如通过 createReadStream 创建文件的读取流时，指定的 data 回调参数就是文件读取到的一个 buffer 片段：
```js
var fs = require('fs');
var rs= fs.createReadStream('test.md');
rs.on('data', function(chunk)) {
	// chunk 就是文件 ‘test.md’ 的一个 buffer 片段
}
```
不过，createReadStream 创建的文件可读流，它每次读取的 buffer 的长度限制为 11。

所以，如果你一边读取一边转义为字符串，可能会出现某种错误：
```js
var fs = require('fs');
var rs= fs.createReadStream('test.md');
var str = ''
rs.on('data', function(chunk)) {
	str += chunk; // 这里会转义调用 chunk.toString() 将 chunk 转义为字符串 
}
console.log(str);
```
会出现什么问题呢？要知道，buffer 会用 1 个位存储 1 个英文字符，但是遇到中文字符串，则需要用 3 个位来存储。前面说过，文件可读流一次读取 11 位 buffer，所以最多转义 9 位 buffer 也就是 3 位中文，剩下 2 位 buffer 无法正常转义，就会成为乱码。

所以，用文件读取流读取到的 buffer 来拼接成字符串时，要注意到这个问题。

那么，剩下的解决方案就是，先将多个小的 buffer 拼接成一个大的 buffer 对象，再一起转义。

### 4.4 buffer 的性能
buffer 直接处理二进制数据，在网络 I/O 和文件 I/O 中有更好的性能。这也是 buffer 被提出的关键原因。

## 五、网络编程
> 略

### 5.1 构建 TCP 服务

### 5.2 构建 UDP 服务

### 5.3 构建 HTTP 服务

### 5.4 构建 WebSocket 服务

### 5.5 构建 HTTPS 服务


## 六、构建 web 应用





