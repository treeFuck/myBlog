# “未闻花名”小程序

「描述」一款实用性的花卉养殖小程序，对海量花卉数据进行了收集整理。该小程序除了提供实用性的花卉知识外，还提供日记模块让用户记录花卉养殖的生活点滴。

「成就」获得2020微信小程序应用开发赛华南赛区二等奖

「职责」花卉字典、种花日记

「项目亮点」用虚拟滚动，减少花卉长列表的实际渲染数量，提高页面整体渲染速度。

「技术要点」mpvue、小程序云存储

## 虚拟滚动原理

假设我们要实现一个滚动的长列表，如果我们一次性就将长列表渲染出来，那么这个渲染的工作量就很大，可能导致渲染的卡顿、滚动的不流畅等问题。

所以，我们需要虚拟滚动这个机制，用重复的多次渲染去替代一次性的大量渲染。

虚拟滚动原理是，我只渲染当前可视区域内的内容，而可视区域的上下则用空白的 DOM 去填充，具体一点就是，监听页面的滚动事件，然后不断计算上下的填充高度和实际上要渲染的内容。


## 能不能更具体地说一下，渲染内容和上下填充内容要怎么去进行计算？
其实是一个数学题。首先你要知道渲染列表里一个渲染元素的高度 h、列表的数量 n。然后，你就可以通过 h\* n = L，计算出长列表的高度。

再然后，你通过当前渲染的元素在长列表里的位置，就可以计算出你要渲染的实际内容是什么，以及该渲染内容对应的上下填充高度。

## 如果使用了虚拟滚动，然后你滚动的很快的话，会造成什么问题？又怎么解决？
1. 滚动过快，渲染来不及 → 除了渲染当前视图的内的元素以外，当前视图的上下也渲染一部分元素，用以缓冲，避免用户滚动太快导致渲染的不及时。
2. 滚动事件触发太快 → 加个节流限制。



## 小程序的双线程是什么？为什么要这样设计？这样设计有什么缺点？如果是你的话你要怎么去改进？



## 说一下防抖的原理，节流呢？
防抖，将一个函数在某一段连续时间内的频繁调用，压缩为一次调用。一般分两类：
1. 延后执行
2. 先执行，在延后下一次的可执行时机

节流，将一个函数在某一段连续时间内的频繁调用，压缩为间隔更大的周期调用。一般分三类：
1. 头执行，尾不执行。这种一般用时间戳去实现
2. 头不执行，尾执行。这种一般用定时器是实现
3. 头尾都执行的，就是前面两种的结合

防抖：
```js
// 第一种防抖：延迟 wait 秒再执行
let debounce2(fun, wait)=>{
	let timer = null
	return function() {
		clearTimeout(timer);
		let _fun = fun.bind(this, ...arguments);
		timer = setTimeout(_fun, wait)
	}
}
// 第二种防抖：先执行，等到不再调用的 wait 后才能再度注册执行
let debounce2(fun, wait) => {
	let timer = null;
	return function() {
		if (timer == null) {
			fun.call(this, ...arguments);
		} 
		clearTimeout(timer);
		timer = setTimeout(()=>{
            timer = null;
        }, wait)
	}
}
```

节流：
```js
// 1. 头执行，尾不执行
let throttle_1 = function(fun, wait) {
	let pre = 0;
	return function() {
		let now = +new Date();
		if (now-pre > wait) {
			fun.call(this, ...arguments);
			now = pre;
		}
	}
}
// 2. 头不执行，尾执行
let throttle_2 = function(fun, wait) {
	let timer = null
	return function() {
		if (timer == null) {
			timer = setTimeout(()=>{
				fun.call(this, ...arguments);
				timer = null;
			}, wait);
		}
	}
}
// 3. 头尾都执行


// 4. 头尾都不执行 → 不存在
```

### 说一下你怎么实现模糊搜索
模糊搜索，简单说，就是监听 input 的输入事件，然后不断把 input 的内容发给后台，然后把后台返回的内容不断渲染出来，但有两个注意点：
1. 发送频率问题。因为用户一般是连续输入，比如用户连续输入两个字符，会触发两次 input，但其实后面那次输入才是用户期待的模糊搜索。所以，前端可以延后 input 回调的执行时机，比如使用防抖，对频繁触发的输入事件进行处理，降低向后台发送请求的频率。防抖的等待时机，我测试过，大约在 0.3 到 0.5 毫秒左右比较合适。
2. 请求响应延后的问题。比如，在搜索框里我先输入关键字 A，没过多久，我又输入关键字 B，这时，浏览器就先发送请求  A 和请求 B 嘛。这时，前端应该忽略请求 A 的响应，而去处理请求 B 的响应。但是，因为异步请求，我们不可能知道哪个请求的响应会更先回来，所以我们需要做点处理，让 js 能判断出当前这个响应是过期的。怎么判断呢？很简单，给每一个请求放一个递增 id，然后在拿到响应的时候判断一下该响应的 id 是否的最新的请求 id。


### 说一下 mpvue 这个框架
一个美团开源的类 vue 框架，用来方便 vue 开发者去开发小程序。但好像不太成熟，用起来很多 bug。目前好像已经停止了更新和维护，过多的我也不了解。

### 说一下小程序云存储
就是，这个小程序里面有一个日记模块，日记需要用户可以上传图片，当时我们没有找到一个合适的图床，然后我就研究了一下云存储，发现存储上限还挺大的，所以就用它来搭了一个临时的简易图床。

当然，只是权益之计，我把上传和下载图片的函数做了封装，一旦找到新的图床，就可以迁移过去。不过后面因为小程序的日记功能不符合个人开发者类目，后台那边停止了小程序的维护，所以就不了了之啦。