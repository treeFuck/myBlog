# 拖拽与拖拽丢失
> ps：以下只讨论拖拽 PC 端实现，不讨论移动端实现。

## 一、前景知识
### 1.1 相关事件
拖拽本质就是三个步骤：**按下鼠标 → 拖动鼠标 → 松开鼠标**。对应的也是三个事件：
1. mousedown：在目标元素区域内按下鼠标
2. mousemove：在目标元素区域内不断移动鼠标（移动过程中不断触发）
3. mouseup：在目标元素区域内松开鼠标

另外，鼠标事件的事件对象 event 有这样的几个属性：
1. event.clientX、event.clientY：鼠标相对于浏览器可视区域左上角的 X, Y 坐标，**单位是 px**。
2. event.screenX、event.screenY：鼠标相对于屏幕左上角的的 X, Y 坐标，单位是 px。
> event.screenX、event.screenY 其实在拖拽里用不到，只是顺便提一下。

### 1.2 相关DOM属性
element.offsetLeft、element.offsetTop：borde 外边框 到 上一级定位元素的 border 内边框 的距离（**如果这个元素是绝对/固定定位元素，那么 offsetLeft、offsetTop 就是 css 的 left、top**）

## 二、实现拖拽
直接看代码：
```js
var dv = document.getElementById('dv'); // 拖拽元素
var con = document.getElementById('con'); // 拖拽区域
var x = 0, y = 0; // 鼠标按下时的位置坐标
var l = 0, t = 0; // 鼠标按下时元素的 left、top
var isDown = false; // 鼠标在目标元素按下了，表示当前是拖拽
/* 鼠标按下事件 */
dv.onmousedown = function(e) {
    // 鼠标初始位置
    x = e.clientX;
    y = e.clientY;

    // 元素初始位置（left、top）
    l = dv.offsetLeft;
    t = dv.offsetTop;

    isDown = true; // 表示鼠标在拖拽元素按下了
    
    dv.style.cursor = 'move'; // 设置鼠标样式  
}
/* 鼠标移动，这个事件会不断触发 */
con.onmousemove = function(e) {
    if (isDown == false) {
        return; // 鼠标没有在目标元素按下，所以不是拖拽
    }
    // 1. 获取鼠标新位置（left、top）
    var nx = e.clientX;
    var ny = e.clientY;
    // 2. 用鼠标偏移量计算元素新的位置
    var nl = l + nx - x;
    var nt = t + ny - y;
	// 3. 通过 style 修改元素位置，实现拖拽效果
    dv.style.left = nl + 'px';
    dv.style.top = nt + 'px';
}
/* 鼠标抬起事件 */
dv.onmouseup = function() {
    isDown = false; // 鼠标抬起了，拖拽结束
    dv.style.cursor = 'default'; // 将鼠标样式还原
}
```
**关键点：**
1. **鼠标按下和鼠标抬起**事件处理程序是在**拖拽元素**上指定，而**鼠标移动**事件处理程序是在**拖拽容器**上指定
2. 鼠标按下时，记录鼠标初始位置和元素初始位置，然后通过拖拽区域**不断触发**的鼠标移动事件来不断计算鼠标偏移来修改元素位置。
3. 鼠标按下时，需要一个变量 isDown 来表示鼠标是否在目标元素按下了，否则拖拽区域的鼠标移动事件无法区分现在是拖拽还是普通的鼠标移动。

## 三、拖拽丢失

暂空