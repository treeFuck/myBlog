# 节流和防抖
> 前景，针对频繁执行的函数，做出执行频率限制。比如 window 的 resize、scroll 事件回调，鼠标的 mousemove 事件回调等。

## 一、防抖
### 1.1 效果
1. **延后执行**：对于频繁调用的函数 A，要等到不再频繁调用它 n 秒后，才去真正执行它。
2. **立刻执行，延后再调用**：对于频繁调用的函数 A，第一次调用时先执行，后面的频繁调用不执行，等到不再频繁调用它 n 秒后才能再次调用执行。
### 1.2 实现
关键点：**保留原函数的 this、参数**
```js
function debounce(func, wait, immediate) {
    let timeout = null;
    if (immediate) {
    	// 立即执行，但要 wait 后才能再度触发，可以有返回值
    	return function() {
    		clearTimeout(timeout);
    		if (timeout === null) {
    			func.call(this, ...arguments);
    		}
    		timeout = setTimeout(()=>{
    			timeout = null;
    		}, wait)
    	}
    } else {
    	// 延迟 wait 秒执行，没有返回值
    	return function() {
    		clearTimeout(timeout);
            let newFun = func.bind(this, ...arguments)
    		timeout = setTimeout(newFun, wait);
    	}
    }
}

let fun = function(e) {
	console.log(e);
}

container.onmousemove = debounce(fun, 1000, true);
```
## 二、节流
### 1.1 效果
节流，顾名思义，将一段频繁调用的函数的真实执行频率控制在一个指定的时间周期里。
### 1.2 实现
关键点：
1. **保留原函数的 this、参数**
2. 在频繁调用的持续时间段里，时间段的头尾是否需要执行函数。
```js
// 头执行，尾不执行
let throttle1 = (fun, wait)=> {
	let pre = 0;
	return function() {
		let now = +new Date();
		if (now - pre >= wait) {
			pre = now;
			fun.call(this, ...arguments);
		}
	}
}
// 头不执行，尾执行
let throttle2 = (fun, wait)=> {
	let timer = null;
	return function() {
		if (timer === null) {
			timer = setTimeout(()=> {
				timer = null;
				fun.call(this, ...arguments);
			}) 
		}
	}
}
// 头尾都执行
let throttle = (fun, wait)=> {
 	let pre = 0;
	let timer = null; // 存储尾调用定时器
	let later = function() {
		pre = +new Date();
		// 尾调用如果不更新 pre，那么尾调用完后就可以立刻执行 fun，不存在 wait 等待 
		timer = null;
		// 尾调用如果没有置空 timer，尾调用完后立刻再次触发fun，不会写入新的尾调用 
		// 所以，上面两步是为了平滑连接两个频繁调用过程的。
		fun.call(this, ...arguments)
	}
	return function() {
		let now = +new Date();
		if (now - pre >= wait) {
			clearTimeout(timer);
			timer = null;
			pre = now;
			fun.call(this, ...arguments);
			// 每执行一次都需要更新一次尾调用
		} else {
			// timer 为空时，更新尾调用
			if (timer === null) {
				let end = later.bind(this, ...arguments);
				timer = setTimeout(end, wait);
			}
		}
	}
}
```