# 滚动

## 一、滚动事件
### 1.1 鼠标滚轮
大多数的浏览器，都提供了 **mousewheel** 事件表示滚轮事件。不过 Firefox 3.5+ 不支持这个事件，但它提供了另一个等同的事件 **DOMMouseScroll** 。

这个事件，要说明几点：
1. 触发时机：**鼠标在目标元素上滚动了滚轮**，目标元素就会触发这个事件。**哪怕这个元素没有滚动条，这个事件也会触发**。**连续滚动滚轮，这个事件会多次触发**。 这个事件**可以冒泡**。
2. 判断方向：借助事件对象 event 判断。
    > 向上滚动滚轮（上拉页面）时，event.wheelDelta 是一个固定的**正数**
    > 向下滚动滚轮（下拉页面）时，event.wheelDelta 是一个固定的**负数**
    > Opera 9.5 之前，正负和上述的是颠倒的
    > 在 Firefox 3.5+ 里是的 event.detail
3. 判断滚动距离：借助目标元素的 scrollTop 变化来判断。

```js
let btn = document.getElementById('btn');

btn.addEventListener('mousewheel', (e)=> {
	if (e.wheelDelta > 0) {
		console.log('向前')
	} else {
		console.log('向后')
	}
})

// 兼容 Firefox 3.5+
btn.addEventListener('DOMMouseScroll', (e)=> {
	if (e.detail > 0) {
		console.log('向前')
	} else {
		console.log('向后')
	}
})
```

### 1.2 滚动条滚动
滚动条滚动时，触发的是 scroll 事件。
1. 触发时机：**目标元素的滚动条滚动了**就会触发该事件。**如果目标元素没有滚动条，那么这个事件必定不会触发**。
2. 判断滚动方向：借助目标元素的 scrollTop 变化来判断。
3. 判断滚动距离：借助目标元素的 scrollTop 变化来判断。
```js
let btn = document.getElementById('btn');
let scrollTop = btn.scrollTop; // 用 scrollTop 记录原本的滚动位置

btn.addEventListener('scroll', (e)=> {
	if (e.target.scrollTop < scrollTop) {
		console.log('上拉')
	} else {
		console.log('下拉')
	}
	scrollTop = e.target.scrollTop;
})
```
### 1.2 二者联系
平时我们滚动页面的时候，都是 滚动滚轮 → 页面滚动。
对应的，**滚动滚轮 → 触发 mousewheel 事件 → 页面滚动 → 页面滚动条滚动 → 触发 scroll 事件**。

所以，页面滚动是属于 mousewheel 事件的默认行为，**如果要禁止页面滚动行为，应该禁止 mousewheel 的默认行为**，而不是禁止 scroll 的默认行为，触发 srcoll 的时候，页面早已经发生了滚动。 

## 二、滚到到指定位置
### 1.1 设置容器的 scrollTop 属性
对于一个有滚动条的容器 con，我们通过设置 con.scrollTop 就可以指定滚动位置。（哪怕没有滚动条，也能滚）

复习一下和滚动有关的几个 DOM 属性：
1. 盒子模型：content + padding + border + margin
2. content 宽高 ：css 指定的 width、height
2. clientWidth、clientHeight：content + padding 的宽高（可视区域的宽高）
3. scrollWidth、scrollHeight：内容层的真实宽、高（可视区域+被隐藏区域）
4. scrollTop：可视区域距离顶部的距离（取值：**0 → scrollHeight - clientHeight**）
5. scrollLeft：可视区域距离左边的距离（取值：**0 → scrollWidth - clientWidth**）

```js
// 滚到顶部：
con.scrollTop = 0;
// 滚到底部：
con.scrollTop = con.scrollHeight - con.clientHeight;
// 滚到左边
con.scrollLeft = 0;
// 滚到右边
con.scrollLeft = con.scrollWidth - con.clientWidth;
```
### 1.2 scrollIntoView() 方法
Element 接口的 scrollIntoView() 方法会滚动元素的父容器，使被调用 scrollIntoView() 的元素对用户可见。调用这个方法可以不传参数，可以传递一个布尔值作为参数，还可以传递一个对象作为参数。

#### 不传参数
```js
element.scrollIntoView(); 
// 等同于 element.scrollIntoView(true)
```
#### 传递布尔值作为参数
```js
element.scrollIntoView(true);
// 相当于 element.scrollIntoView({block: "start", inline: "nearest"}) 
element.scrollIntoView(false);
// 等同于 element.scrollIntoView({block: "end", inline: "nearest"}) 
```
#### 传递对象作为参数
这个参数对象有三个可选属性：
1. behavior：定义动画过渡效果， "auto"或 "smooth" 之一。默认为 "auto"。
2. block：定义垂直方向的对齐， "start", "center", "end", 或 "nearest"之一。默认为 "start"。
3. inline：定义水平方向的对齐， "start", "center", "end", 或 "nearest"之一。默认为 "nearest"。
> nearest 是哪个近和哪个对齐的意思
```js
element.scrollIntoView({block: 'start', inline: 'start'})
// element 左上角和可视区域左上角对齐
element.scrollIntoView({block: 'end', inline: 'end'})
// element 右下角和可视区域右下角对齐
element.scrollIntoView({block: 'start', inline: 'end'})
// element 右上角和可视区右上角域对齐
element.scrollIntoView({block: 'end', inline: 'start'})
// element 左下叫和可视区域左下角对齐
```
> Internet Explorer 和 Safari 都不支持 scrollIntoView 参数为一个描述对象，只支持布尔值参数。

#### scrollIntoViewIfNeeded 方法
这个方法也可以将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域，属于标准的 Element.scrollIntoView() 方法的专有变体。

它的参数只能是布尔值，默认为 true
1. 参数为 true 时，元素将在其所在滚动区的可视区域中居中对齐
2. 参数为 false 时，元素将与其所在滚动区的可视区域最近的边缘对齐

> scrollIntoViewIfNeeded 方法的对齐都是垂直方向对齐，水平方向的对齐还是 nearest。 另外，Firefox、Internet Explorer 不支持这个方法

### 1.3 将可以成为焦点的元素设为焦点
通过 element.focus() 方法可以将 element 元素设为页面焦点，页面焦点会自动显示到页面中间。（垂直 / 水平都居中）

前提是，element 可以获得焦点（比如 input、button、textarea）

```js
let str = '';
for (let i = 0; i < 300; i++) {
	str += `<button>${i+1}</button>`
}
document.body.innerHTML = str;

let p = document.body.lastElementChild;

setTimeout(()=>{
	p.focus()
	console.log(document.activeElement)
	// 通过访问 document.activeElement 可以知道当前页面焦点是哪个元素
}, 1000)
```
## 三、虚拟滚动
应用场景：针对长列表的渲染。

原理：只渲染当前视图内的元素，上下高度用空白 DOM 填充，然后监听滚动事件，不断计算你要渲染的内容，和上下要填充的高度。







