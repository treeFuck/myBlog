# 模拟面试

## 一、自我介绍
面试官，您好。

我是来自广东工业大学计算机学院的王树干，目前是软件工程专业一名大三的学生。

大学实践方面，我参加学院的辩论队，并参与过一些大大小小的辩论赛，锻炼了自己的沟通和表达能力。

学习方面，我加入了学院里一个优秀创新团队——QG工作室，在里面担任前端开发的工作，参与过多许多大大小小的项目和各种各样的比赛，让我学习到许多前端相关的专业知识。

技术栈方面，我除了熟悉前端基本的三剑客外，还熟悉 Vue 全家桶的使用，另外还深入阅读过 Vue 全家桶的源码了解他们的底层原理实现。另外，在前沿知识方面，我有了解过微前端的具体实现原理。

## 二、项目
### 2.1 QG 2020 招新网
我们工作室用以宣传招新的一个纯前端网站，结合结合一些动画和排版设计来介绍我们工作室。这个项目最大的亮点，我用了一些技巧对网页性能进行了多维度的优化：
1. 首先是静态资源加载方面：
	1. 压缩，我对字体包进行的字蛛压缩，图片也进行了无损压缩
	2. 加快下载速度，我把页面全部静态资源都挂到阿里云 oss 对象存储上
	3. 这方面的优化，将首页白屏时间从大概从 0.8 毫秒降低到了 0.1 毫秒，用户一般察觉不到。
2. 动画帧卡顿的优化：
	1. 用 requestAnimationFrame 改写定时器动画，做到一帧一渲染，避免阻塞
	2. 用 web woker 开了一个子线程，分离 js 引擎线程上的计算任务，避免它阻塞 GUI 渲染线程而造成动画卡顿
	3. 用 css3 开启 GPU 硬件加速，大大优化手机端动画的渲染性能

**拓展问题：**什么叫一个流畅的动画？

> 答：动画本质是帧的切换，切换得越快，动画越流畅；切换得越慢，动画越卡顿。因为显示器的刷新频率大多是 60 HZ，所以**一个流畅的动画对应的页面重新渲染频率最好是 16.67 ms 一次**。
>
> 另外在浏览器内核进程里，js 引擎线程和 GUI 渲染线程是互斥的。也就是说，**在一个动画的一帧里， js 执行+重新布局+重新绘制 ≈ 16.67 毫秒，那么这个动画就是流畅的**。

### 2.2 “未闻花名”小程序
这个一个类似于花的“字典”的小程序，主体功能是查询各类花卉的信息。在这个功能上我们拓展出其他的一些功能，比如每天给用户推荐一朵花、根据花的含义进行送花推荐、提供日记模块给用户记录有关种花的生活日常等。

我负责的是其中花卉字典和种花日记模块。

项目两点的话，有两个点：
1. 第一，是对全部 ajax 请求进行的统一的封装，让其他开发者只需关注请求成功后的逻辑。请求出错的话，会弹出错误提示框，没有登陆 token 的话，重定向回登录页等。
2. 第二，是花卉字典里需要展示一个无限下拉的花卉列表。直接一次渲染的话，会造成页面卡顿。为此，我用了虚拟滚动，去xxxx


### 2.3 构建民航业知识图谱并实现语义查询
这个第九届软件杯比赛的一个赛题，前端这边的工作主要是展示一个知识图谱。为了让这个知识图谱更具有操作性，比如点击、拖拽、放缩等，我使用了 svg 和 d3 来绘制知识图谱。

项目的亮点的话，是我对知识图谱 svg 的 d3 操作进行了封装，并用 proxy 代理将它维护成一段响应式数据，这样子其他开发者只需要关注数据本身，而不需要关注 d3 是怎么绘制 svg 的。

## 三、前沿知识
### 3.1 说一下微前端是什么？

### 3.2 微前端和 iframe 的区别在于哪里，为什么要使用微前端而不使用 iframe ?

### 3.3 微前端的状态隔离是怎么实现的？css 和 js 的隔离有什么不同 ？

## 四、 计网

### 4.1 说一下 TCP 和 UDP 的区别
- TCP 是面向连接，提供可靠交付的一条点对点的全双工通道
- UDP 是无连接，尽最大努力交付，支持一对一、一对多、多对一和多对多的交互通信

### 4.2 说一下 TCP
TCP 是面向连接的，提供可靠交付的，建立一条点对点全双工通道进行的通信。

它通过三次握手建立连接，四次挥手断开连接。

另外，它通过滑动窗口协议来实现可靠传输和流量控制，通过“慢开始、拥塞避免、快重传、快恢复”四个算法来实现拥塞控制。

### 4.3 说一下 TCP 三次握手
1. 第一次握手：客户端发送一个 SYN=1，ACK = 0 的报文给服务端，表示请求建立连接
2. 第二次握手：如果服务端收到第一次握手的请求报文后，如果同意建立连接，返回一个 SYN=1，ACK=1 的响应报文
3. 第三次握手：客户端收到服务端的响应报文，还需要再给服务端发送一个 ACK=1 的确认报文。

第三次握手的目的，是为了防止已经失效的请求再次抵达服务端而产生错误。一个失效的连接请求发送到服务端，服务端依旧会返回一个确认给客户端。但因为这是一个失效请求的确认，所以客户端会无视它，不会发起第三次握手。服务端没有收到第三次握手，就明白刚刚的请求是失效的，不会建立连接。
### 4.4 说一下 TCP 四次挥手
1. 第一次握手：客户端发送一个 FIN=1 的报文，表示断开连接
2. 第二次握手：服务端收到客户端第一次挥手报文后，返回客户端一个确认，表示自己已经收到了请求，但是它还没准备好，可能还有一些其他的请求没处理完毕。
3. 第三次握手：服务端准备好断开连接了，就给客户端发送一个 FIN=1 的报文，表示断开连接
4. 第四次握手：客户端收到第三次握手的报文后，给服务端发送一个确认报文。服务端收到确认报文后，就可以释放连接了，但是客户端还需要等待 2MSL 的时间才断开连接。等待 2MSL 的目的是，确保第四次握手成功发送到服务端，以及处理服务端可能的对“已失效连接请求”的确认返回。

### 4.5 说一下 HTTP/1.1 和 HTTP/2.0 的区别
1. HTTP/2.0 的多路复用：
	- HTTP/1.1是串行共享一个 TCP 连接，上一个请求结束了，下一个的请求才会发起
	- HTTP/2.0 实行并行策略，多个请求可同时在一个 TCP 连接上并行执行，也叫多路复用
2. 数据流格式不一样：
	- HTTP/1.1 使用的是文本流
	- HTTP/2.0 使用的是二进制分帧，服务器解析起来会更快
3. 首部压缩
	- HTTP/1.1 首部不会压缩，每一次请求都需要发送一个新的首部
	- HTTP/2.0 在客户端和服务端之间维护一个首部字段表，这个首部字段表会包含之前出现过的首部字段，每次发起请求只会发送要更新的首部字段。另外，还使用了编码算法对首部进行压缩
4. 服务端推送
	- HTTP/1.1 不支持服务端推送
	- HTTP/2.0 支持服务端推送

### 4.6 说一下 HTTPS
HTTP 有三个缺点：
1. 明文传输 → 内容可能被窃听
2. 不验证通信双方 → 通信方可以伪造
3. 不验证报文完整性 → 报文可能被篡改

所以，提出了 HTTPS。

1. 加密：加密方式有两种，共享密钥加密和公开密钥加密。HTTPS 采取两者混合方式进行通信内容的加密。首先，通信双方先通过公钥加密传递一把共享密钥，然后后续的通信用这边共享密钥进行通信。
2. 验证通信双方：服务端的公钥需要提交给第三方权威机构进行认证，第三方机构会给公钥颁发证书，证书上有一个数字签名，这个签名用第三方机构私钥加密。服务端在给客户端发送公钥的时候把证书也发过去，客户端本地拥有第三方机构的公钥，可以认证证书上的数字签名的真实性，进而认同证书的权威性，也就相信了发送公钥的服务端。这个是客户端认证服务端。也存在客户端证书让服务端认证客户端，但是比较少，加格也昂贵。
3. 验证报文完整性：通过报文摘要来验证报文完整性。HTTP 也报文摘要，但因为它是明文传输，所以报文摘要也很容易进行篡改。HTTPS 因为加密导致报文摘要的成功篡改比较困难，进而可以保证报文完整性。

优点：能解决 HTTP 的三大缺点
缺点：因为需要对通信内容进行加密和解密，传输速度比 HTTP 慢；需要购买证书，需要一定成本。
		

### 4.7 说一下跨域
首先，跨域是什么？
跨域是因为浏览器的同源策略，导致 AJax 无法对非同源的资源进行请求。
同源的意思是：相同协议+相同域名+相同端口

然后，怎么解决？
第一，JSONP。
创建一个 script 标签插入文档，script 不受同源策略限制，会对它的 src 发起 get 请求，然后将响应数据传入指定的回调函数，我们从那个回调函数里获取 JSONP 跨域请求的响应。
优点是简单，而且不需要服务端做出修改。
缺点是只能发起 get 的跨域请求。

第二，CORS。
CORS 也叫跨域资源共享。一般是客户端发起请求的时候，在首部 Origin 字段告诉服务器自己的源，服务器判断该请求源是否在自己的允许跨域白名单里，如果在的话就同意跨域返回响应。另外对于一些特殊请求，比如发送 json 数据的 post 请求，浏览器会先发送一个 option 预检请求。

优点是：能够解决全部请求类型的跨域问题。
缺点是：不兼容一些较老的浏览器，而且需要服务端配置

第三，代理服务器
在本地搭建一个与页面同源的代理服务器，页面向代理服务器发送请求，代理服务器向真实服务器转发请求。常见的有 nodejs 代理服务器和 nginx 反向代理。

优点是：不需要服务端修改
缺点是：代理服务器搭建麻烦，不过可以结合一下脚手架工具来简化搭建工作

## 五、浏览器机制
### 5.1 说一下浏览器内核的多线程
浏览器本身是多进程的一个应用：
1. browser 主进程：负责协调、主控其他进程
2. GPU 进程：负责 3D绘制
3. 插件进程：一类插件对应一个进程，使用插件的时候才会被创建
4. 最重要的渲染进程，也叫浏览器内核，内部是多线程的
	- JS 引擎线程：执行 js 脚本代码，比如 v8 引擎。和 GUI 渲染线程互斥
	- GUI 渲染线程：负责解析 HTML、解析 css、回流、重绘。和 js 线程互斥
	- 事件触发线程：控制事件循环，将回调放到任务队列待执行
	- 定时器触发线程：给定时器计时，计时完毕将回调放到任务队列
	- 异步 http 线程：检测 http 请求状态，在请求完毕后将指定回调放到任务队列 

其中，js 引擎线程和 GUI 渲染线程是互斥，因为 js 可以访问 DOM，而 GUI 渲染又依赖一个稳定的 DOM，如果两个可以并行，那么 DOM 的渲染可能会出现错误。

web worker 可以开启一个 js 引擎线程的子线程，它受控于 js 引擎线程，一般用来分离 js 线程的计算任务，避免 js 引擎线程因为 js 计算任务过大而阻塞了 GUI 渲染线程，导致不能及时渲染而产生页面卡顿。

### 5.2 说一下从输入 url 到页面渲染完毕之间的过程



## 六、js + ES6
### 6.1 说一下闭包
什么是闭包？简单来说，就是一个函数，它能够访问另外一个函数作用域。通常的用法，是比如在函数 A 里定义函数 B 并返回，这时执行 A 得到的 B 就是一个闭包。

闭包的作用：
1. 能够访问另外一个函数的作用域；
2. 创建闭包的函数执行完后它变量对象不会被立即回收，所以可以对闭包的作用域链进行特例化。

闭包的缺点：
1. 闭包会导致一些变量不被垃圾回收机制回收，造成内存消耗
2. 过度使用闭包会造成内存泄漏 

### 6.2 为什么闭包会导致一些变量无法被回收
首先我们要知道，一个函数的作用域链创建过程：
1. 函数定义时：将所在作用域的作用域链赋给函数的 [[Scope]] 变量
2. 函数执行时：生成自己的 AO 对象，复制 [[Scope]] 并将 AO 放到最前面，这样就得到自己的作用域链

正常一个函数执行完毕后，它的作用域链和变量对象都要被回收。
但闭包不一样。比如在 A 里定义 B 并返回，B 的 [[Scope]] 会一直引用着 A 的变量对象，导致它不能被正常回收。

### 6.3 什么是内存泄漏
内存泄漏是指，一块内存不被应用程序使用，但是又因为其他原因而无法进行回收利用。内存泄漏可能会导致应用程序卡顿或奔溃。

### 6.4 说一下原型
js 规定，每一个构造函数都有一个原型指针，指向它的原型对象。而构造函数创建处理的实例，也有一个原型指针，指向这个原型对象。

原型有什么用？js 规定，当访问一个对象上的某个属性访问不到时，就会向它的原型上找该属性，如果原型上还找不到，就到原型的原型上找，一直找到原型为 null 为止。

原型上还有原型，就形成了原型链，Object 构造函数的原型是一切原型链的终点，因为 Object 构造函数的原型的原型是 null。

另外，原型链可以用来实现继承。

### 6.5 说一下继承
传统的 js 继承，大致分三类：
借用构造函数继承：在子类构造函数内部通过 call 去执行父类构造函数。
优点：通过给父类构造函数传参，可以给子类特例化属性继承
缺点：每个实例都拥有自己的但功能相同的继承方法，造成内存浪费。

原型链继承：指定一个对象的原型是另一个对象。
优点：可以做到方法继承的复用
缺点：但属性的继承是全部实例共享，无法特例化

组合继承：借用构造函数继承来继承属性，原型链继承来继承方法
优点：结合前面两者的优点

另外，ES6 提出了一种 class 语法糖，它的继承模式和组合继承类似，但也有一定区别

### 6.6 class 继承和组合继承的区别
- 组合继承：先创建子类 this，再通过 call 执行父类构造函数来修改 this
- class 继承：先执行 super 创建父类 this，再执行子类构造函数来修改 this

### 6.7 class 和传统构造函数的区别
- class 定义是原型方法都是不可枚举的，传统构造函数的原型方法是可枚举的
- class 必须要 new 操作符来执行，构造函数可以不用 new（比如用 call 指定 this）
- class 不会变量提升，构造函数 function 可以变量提升
- class 不支持私有属性、私有方法，构造函数支持定义私有属性、私有方法
- 继承机制不一样：class 是先创建父类 this，在执行子类构造函数来修改 this；构造函数是先创建子类 this，再执行父类构造函数修改 this
- class 允许用 extend 操作符来继承原生的构造函数，比如对象构造函数 Object、Array

### 6.8 说一下作用域和作用域链
一个函数的作用域，就是这个函数所能访问的变量范围。

作用域链的产生，分两步：
1. 函数定义时，会用函数的 [[Scope]] 内部属性去指向，函数定义所在的作用域链。如果是在全局范围，那么这个作用域链就是一个简单的 GO 对象
2. 函数执行时，会用执行的参数、内部变量等创建一个变量对象 AO，并复制 [[Scope]] 内部属性上的作用域链，将 AO 对象放到作用域链最前端，这样就是产生了它自己的作用域链。

### 6.9 说一下 this 
this，可以简单理解为函数的作用域。一个函数 this 的指向，分五类：
1. 默认绑定：非严格模式下，this 默认是 window；严格模式下，this 默认是 undefined
2. 隐式绑定：谁调用这个函数，那么 this 就指向谁。隐式绑定优先级高于默认绑定。
3. 显示绑定：通过 call、bind、apply 指定函数的 this。显示绑定的优先级高于隐式绑定。
4. new 绑定：new 是创建一个空对象然后让函数的 this 指向这个空对象。new 绑定的优先级高于显示绑定
5. 箭头函数的 this：箭头函数的 this，是它外部作用域的 this。对于箭头函数而言，显示绑定和 new 绑定都无效

### 6.10 call 和 apply 哪个更快
call，因为 apply 还需要从数组里把参数给读取出来。
### 6.11 写一个 call / apply / bind
```js
Function.prototype.callFun = function(context, ...args) {
	if (!context) {
		context = window; // context 为空，则绑定作用域为 window
	} else if (context instanceof Object === false) {
		context = new Object(context); // context 为非对象，转化为对象
	}
	context._fun = this;
	let res = context._fun(...agrs);
	delete context._fun;
	return res;
}

Function.prototype.bindFun = function(context, ...args1) {
	if (!context) {
		context = window;
	} else if (typeof context !== 'object') {
		context = new Object(context);
	}
	let thatFun = this;
	let fun = function(...args2) {
		if (this instanceof fun) {
			// 如果正在执行 new fun，则 context 应该为 fun 的 this
			context = this;
		}
		thatFun.apply(context, [...args1, ...args2])
	}
	fun.prototype = thatFun.prototype; // 复制原型，避免 new 出错
	return fun;
}
```


### 6.12 写一个 new
new 构造函数创建实例的流程：
1. 创建一个空对象 A
2. 将 A 的原型 A.\_proto\_ 指向构造函数的原型 Ctor.prototype
3. 将构造函数的 this 绑定为空对象，并执行
4. 如果构造函数执行没有返回值，返回空对象 obj
5. 如果构造函数有返回值 res：
	5.1 返回值 res 是个对象，返回 res
	5.2 返回值 res 不是对象，返回 obj

代码模拟：
```js
let newFun = (Ctor, ...args)=> {
	let obj = Object.create(Ctor.prototype);
	let res = Ctor.apply(obj, args);
	return res instanceof Object ? res : obj;
}
```
### 6.13 DOM 操作方法里有没有 insertAfter ? 没有的话能不能模拟？
没有，可以用 insertBefore 和 appendchild 来模拟
```js
Node.prototype.insertAfter = function(newEl, target) {
	let parent = target.parentNode;
	if (target === parent.lastChild) {
		parent.appendChild(newEL);
	} else {
		parent.insertBefore(newEl, target.nextSibling)
	}
}
```
### 6.14 说一下 Promise 实现原理

### 6.15 说一下 async 原理

### 6.16 说一下 js 里的遍历



## 七、HTML + CSS + SVG
### 7.1 说一下盒子模型
css 里的盒子，包括四个元素：
1. 实际内容 content
2. 内边距 padding
3. 边框 border
4. 外边距 margin

标准盒子模型的话，css 里的 height、width 指定是 content 的宽高
怪异盒子模型的话， css 里的 height、width 指定是 content + padding + border 的宽高

通过指定 css 属性 box-sizing 为 content-box 就可以将该盒子设为标准盒子模型
而将 box-sizing 设为 border-box 就可以将盒子设为怪异盒子模型

### 7.2 说一下文档流和文本流
文档流：元素布局的方式。具体是块级元素独占一行，行级元素从左到右排列
文本流：文本布局的方式。

绝对定位和固定定位都能让元素脱离文档流，元素文本脱离文本流；
float 浮动可以让元素脱离文档流，但不会让元素文本脱离文本流，所以适合制造文本环绕效果。

### 7.3 浮动的影响和消除浮动
浮动一般会影响它的父元素和兄弟元素：
1. 因为脱离文档流，如果父容器没有指定高度，父容器会高度坍塌。解决方案：
	1. 将父容器设为 BFC，比如将父容器 overflow 设为 hiddhien
	2. 给浮动元素后的普通文档流元素添加“clear: both”，一般是给浮动元素添加伪类来实现
2. 因为脱离文档流，后面的元素原有布局可能被打乱。解决方案
	1. 一样，给浮动元素后的普通文档流元素添加“clear: both”，一般是给浮动元素添加一个伪类

### 7.4 什么是 BFC
BFC，块级格式化上下文。具有 BFC 特性的元素可以看做一个隔离的独立容器，不论它里面的元素怎么布局，都不会影响到外部。

BFC 元素，有 5 种：
1. body 根元素，默认是 BFC
2. 浮动元素
3. 绝对对象和固定定位元素
4. display 为 inline-block、flex 等
5. overflow 是 hidden、auto、scroll（不是 visible 就行）

BFC 的特性：
1. 在同一个 BFC 里，上下两个盒子的 margin 会合并
2. 计算 BFC 高度时，把浮动的子元素也计算在内
3. BFC 内部元素布局和外部元素布局相互隔离，互不影响
4. BFC 元素不会与 float 元素重叠

### 7.5 SVG 和普通的图片有什么不同


### 7.6 SVG 和 canvas 有什么不同

### 7.7 说一下 SVG 的 viewBox 属性


## 八、Vue + Vuex + VueRouter
### 8.1 说一下 vue 组件通信方式

### 8.2 说一下 Vuex 原理（让你设计一个 Vuex 你怎么设计）

### 8.3 说一下 Vuex 的单向数据流

### 8.4 说一下 Vue-Router 原理 （让你设计一个 Vue-Router 你怎么设计）
分三个点来设计：
1. url 匹配组件
2. 管理路由，比如 history
3. 路由状态和组件渲染怎么联系起来

### 8.5 Vuex-Router 有几种路由，他们有什么差别

### 8.6 说一下 Vue 响应式系统，让你设计的话你怎么设计

### 8.7 Vue3.0 的响应式系统和 Vue2.x 的响应式系统有什么区别

### 8.8 说一下 Vue 的模板编译

### 8.9 说一下虚拟 DOM 的意义

### 8.10 说一下 Vue 的 diff 算法

## 九、git

## 十、webpack
### 10.1 说一下模块化

### 10.2 说一下 webpack 的打包原理

### 10.3 说几个你常用的 loader

## 十一、小程序

### 11.1 小程序和传统的 H5 应用有什么区别

## 十二、nodejs

### 12.1 说一下 node 的事件循环


