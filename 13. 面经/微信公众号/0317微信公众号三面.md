# 0317微信公众号三面（40分钟笔试 + 25分钟面试）

算法：

```js
1、
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
123 + 456
L1 3 2 1
L2 6 5 4

ListNode
ListNode* next
int value

ListNode* addTwoNumbers(ListNode* l1, ListNode* l2){
    let p1 = l1;
    let p2 = l2;
    let ten = 0; // 进位
    let _head = new ListNode();
    let pre = _head;
    while(p1 || p2 || ten) {
        let vl1 = (p1 && p1.val) || 0;
        let vl2 = (p2 && p2.val) || 0;
        let sum = v1l + vl2 + ten; // 相加
        
        let p = new ListNode(sum % 10); 
        ten = Math.floor(sum/10); // 进 1 位
        
        pre.next = p;
        pre = p;
        
        p1 = p1.next;
        p2 = p2.next;
    }
    return _head.next;
}

2、给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

int lengthOfLongestSubstring(char * s){
 // 滑动窗口 + 动态规划
 let set = new Set(); // 去重
 let i = 0;
 let res = 0;
 let len = s.length;
 for (let j = 0; j < len; j++) {
     let char = s[j];
     while (set.has(char)) {
         // 不断移除重复的字符
         set.delete(s[i]);
         i++;
     }
     // i → j，就是以 s[j] 结尾的无重复字符子串
     res = Math.max(res, j-i+1); 
 } 
 return res;
}

3、K 个一组翻转链表
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例：
给你这个链表：
1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5//here
说明：
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next; };
 */}
// 这个思路有点 bug，没有看见不能用常数空间
ListNode* reverseKGroup(ListNode* head, int k) {
    // 1. 先计算链表的长度
    let len = 0;
    let p = head;
    while（p） {
        len++;
        p = p.next;
    }
    
    // 2. 用栈去翻转链表
    let stack = [];
    let time = len - len%k; // 翻转次数
    let i = 1; // 记录当前是第几次翻转
    let _head = new ListNode(); 
    let pre = _head;
    let p = head;
    while (i <= time) {
        stack.push(p);
        let next = p.next;
        if (i % k == 0) {
            // 遇到了周期节点，这个时候进行拼接
            while(stack.length) {
                // 利用栈来进行逆转
                let order = stack.pop();
                order.next = null;
                pre.next = order;
                pre = order;
            }
        } 
         p = next;
         i++；
    }
    // 最后可能还有剩余，需要继续连接
    pre.next = p;
    return _head.next;
}

4、给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

示例 2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
// 方法1：利用双向队列 → 不断把队尾移动到队头
void rotate(int* nums, int numsSize, int k){
    k = k % (nums.length); // 求余，避免冗余操作
    while (k) {
        nums.unshift(nums.pop());
        k--;
    }
    return nums;
}
// 方法2：旋转 2 次
void rotate(int* nums, int numsSize, int k){
    k = k % (nums.length); 
    nums.reverse(); // 第一次旋转
    // 把前 k 旋转，把后 k 旋转
    let arr1 = nums.slice(0, k).reverse();
    let arr2 = nums.slice(k,).reverse();
    return [...arr1, ...arr2];
}


```

1. 输入 url 到页面渲染的过程经历了什么？

2. 说一下 HTTP/1.1 的 keep-alive 和 HTTP/2.0 的多路复用

3. 在 head 标签里引用了 5 个 css 和 5 个 js，每一个下载耗时是 10 s，那么下载资源的总体耗时，对于 HTTP/1.1 和 HTTP/2.0  而言有什么区别？

   > 说的时候，因为不确定，用了很多 ”应该、可能吧“ 的语气词。
   >
   > 面试官：嗯……我是这么思考面试过程的：如果你不知道，那么我们可以换别的话题；如果你知道，我希望你能说得清楚答案为什么是这个，而不是给我一个猜测的答案。

4. 说一下 js 的事件循环

5. 举个例子，我有一个变量 i=0，然后我每隔 50 毫秒注册一个定时器，一个定时器会把 i +1，那么 100 毫秒的时候，我的 i 值会是什么？一定是吗？

6. 说一下你对 webpack 的了解

7. webpack 只处理的文件只会是 js 和 css 吗？

   > 说了一下 loader，举了 sass 文件转义的例子

8. 有没有了解 webpack 的一些拓展功能，具体说一下

   > 说了代码分片和 tree-shaking

9. 反问环节