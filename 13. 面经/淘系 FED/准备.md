# 准备

## 一、计网

### 1.1 说一下 HTTPS
HTTP 有三个缺点：
1. 明文传输 → 报文容易被窃听
2. 不验证通信双方 → 通信方可以伪造
3. 不验证报文完整性 → 报文可以被篡改 

所以，提出了 HTTPS。

第一，加密。
HTTPS 通过密钥加密的方式进行通信。密钥加密有两者方法：

1. 共享密钥加密 → 一把密钥，即能加密也能解密
2. 公开密钥加密 → 一把公钥，用来加密，可以随便发布；一把私钥，放在服务器，用来解密。
HTTPS 先通过公开密钥加密的方式传递一把共享密钥，后续的通信都使用共享密钥来进行加密通信。

第二，验证通信双方。
服务端在向客户端发送公钥的时候，把公钥的证书也发送过去。这个证书是由第三方权威机构颁布的，上面有一个数字签名，用第三方机构的私钥进行加密过。客户端收到公钥和证书后，用本地存放的第三方机构公钥校验数字签名的合法性 → 认证了证书的合法性 → 认证了公钥合法性 → 信任服务端。

第三，验证报文完整性。
HTTPS 通过报文摘要来验证报文完整性。其实 HTTP 也提供报文摘要来验证报文完整性，但是因为报文是明文传输，报文摘要也可以被篡改。但是 HTTPS 是密文传输，想要成功篡改报文摘要是很困难的。

### 1.2 说一下 HTTP1.1 和 HTTP 2.0 的区别：
1. 多路复用：
	- HTTP 1.1 里，发送一个请求后，必须等待该请求响应返回了，才能发送下一个请求报文。
	- HTTP 2.0 里，可以并行发送请求，而不用等待上一个请求响应 → 多路复用同一个 TCP 连接
2. 数据流格式
	- HTTP 1.1 里，数据流是字符串
	- HTTP 2.0 里，数据流是二进制帧，服务器解析起来更快
3. 首部压缩
	- HTTP 1.1 里，首部没有压缩，每一次请求都要发送一个新的首部
	- HTTP 2.0 里，在客户端和服务端之间维护了一个已发送首部字段，每次发送请求只要发送要更新的首部字段就行。并且还使用了算法对首部进行压缩
4. 服务端推送
	- HTTP 1.1 不支持服务端推送
	- HTTP 2.0 支持服务端推送

#### 1.3 TCP 和 UDP 的区别
- TCP 是面向连接的，提供可靠交付的，建立一条点对点全双工通道进行通信的协议
- UDP 是无连接的，最大努力交付的，支持一对一，一对多、多对一、多对多通信的协议

#### 1.4 TCP 三次握手
- 第一次握手，客户端发送 SYN=1，ACK=0 的报文，发起连接请求
- 第二次握手，服务端同意连接，则返回 SYN =1，ACK = 1 的报文
- 第三次握手，客户端收到第二次握手后，需要给服务端返回一个 ACK=1 的确认报文

第三次的握手的意义是，避免已经失效的连接请求又到了服务端而引发错误。

对于这种情况，服务端会任务客户端又发起连接请求，则依旧返回一个响应报文。客户端拿到这个响应报文后，会知道这个是对已经失效的连接请求做出的响应，而无视它，所以不发起第三次握手。而服务端因为没有第三次握手，就不会建立建立。

如果没有第三次握手，第二次握手的时候，服务端就以为建立了连接。那么对于失效的连接请求这种情况，就产生：服务端以为建立了连接，而客户端没有建立连接 的情况。

#### 1.5 TCP 四次挥手
- 第一次挥手，客户端发送 FIN=1 的报文，请求断开连接
- 第二次挥手，服务端收到客户端的请求断开连接报文后，返回一个报文给客户端，表示它已经收到断开连接的请求了，但是这个时候它可能还没准备好
- 第三次挥手，服务端准备好断开连接了，就返回客户端一个 FIN=1 的报文
- 第四次挥手，客户端收到服务端断开连接报文后，给服务端返回一个确认报文。服务端收到确认报文后，就正式断开连接，但是客户端还要等待 2MSL 才断开连接。

为什么要等待 2MSL 呢，主要是防止第四次挥手没有正常到达服务端，超时后服务端又发起第三次挥手，这时需要客户端去接住第三次挥手并重新发起第四次挥手。

#### 1.6 跨域
跨域是因为浏览器的同源策略限制。什么是同源呢，就是 协议、域名、端口都相同。

解决跨域问题有三次方法：
第一，JSONP。
因为 script 标签不受同源策略限制，所以用 js 动态创建一个 script 标签，并在 src 里指定 get 请求地址和回调。将 script 标签插入 DOM 后，会发起一个 GET 请求，响应会作为刚刚指定的回调函数参数而被拿到。

缺点是只针对 GTE 请求。优点是兼容性好，可以兼容很多老的浏览器。

第二种，CORS 跨域资源共享。
客户端发起请求后，在 origin 字段说明请求源，服务端收到请求后，根据请求源来判断是否同意该跨域请求。有一些特殊请求，比如发送 json 数据的 post 请求，会让提前发送一个 option 预检请求。

优点是，能支持多种请求，缺点是不兼容一些老的浏览器，而且需要服务端那边配合配置。

第三种，代理服务器。
在前端页面同源的地方搭建一个代理服务器，用来转发前端的请求到真实的服务器。常见的有 NodeJS 代理服务器，Nginx 反向代理。

优点是不需要服务端修改，缺点是需要学会代理服务器的搭建，不过一般可以通过脚手架工具来简化操作。

## 二、浏览器机制

### 2.1 浏览器缓存

### 2.2 浏览器多线程
浏览器本身是一个多进程的应用，常见的进程如下：
1. 浏览器主进程，负责管理其他的进程，下载网络资源等
2. GPU 进程，负责 3D 绘制等
3. 插件进程，一类插件对应一个进程，使用插件的时候才会创建
4. 渲染进程，也叫浏览器内核，它的内部是多线程的

浏览器内存多线程：
1. js 引擎线程，负责解析执行 js 代码，比如 V8 引擎
2. GUI 渲染引擎，负责解析 html、css，生成 render 树、布局、绘制等
3. 事件触发线程，负责管理事件循环，将已经触发的事件回调放到任务队列
4. http 异步请求线程，负责 http 的请求，将请求完毕的回调放入任务队列
5. 定时器线程，负责对定时器进行计时，将计时完毕的回调放入任务队列

其中，js 引擎线程和 GUI 渲染线程是互斥的，因为 js 可以操作 DOM，但 GUI 渲染依赖一个稳定的 DOM 的结构，如果让两者可以并行，那么可能会发送不可预知的错误。

另外，可以创建 web worker 子线程，不过它受控于 js 主线程。一般是将 js 主线程复杂的计算任务分离到子线程，二者通过异步 api 进行通信，避免 js 线程阻塞 GUI 渲染线程而造成页面卡顿。

### 2.3 说一下浏览器的垃圾回收
垃圾回收主要说的是 V8 引擎对堆内存的回收。因为存在一些堆内存里的引用对象，它在栈内存里不存在有一个指针指向它，那么这个对象就成为了无法被引用的对象，失去了意义，成为了“垃圾”需要被回收。

V8 的垃圾回收基于分代式垃圾回收策略。分代是意思是将对象分为新生代和老生代，对应的内存页分为新生代内存和老生代内存。

其中，新生代对象，指的是存活周期比较短的对象，比如一个函数里用局部变量引用的对象。新生代对象的垃圾回收方法采用的 GC 复制算法，将新生代内存一分为二，一个叫 From，一个叫 To:
1. 分配内存时，只分配到 From 里
2. 垃圾回收时，将 From 里还存活的对象复制到 To里，剩下的非存活对象就销毁回收
3. 复制完毕，将就 From 和 To 进行角色调换

而老生代对象，就是存活周期比较长的对象，比如全局变量引用的对象、一些被闭包引用的对象等。它们采取的是标记-清除和标记-整理算法。
标记-清除，分为标记和清除两个阶段：
1. 标记阶段，从根变量开始向下递归遍历对象的引用，将对应的堆内存空间做上标记
2. 遍历堆，将堆内存里没有被标记到的对象进行销毁回收 → 因为这些对象无法被引用到了，所以没有意义，只能被回收

标记-清除有一个缺点，是进行垃圾回收后，可能会产生一片不连续的内存空间，那么当需要使用一片连续大内存时可能会触发又一次的垃圾回收。

为了避免这个问题，提出了标记-整理算法，通过移动堆内存里的存活对象，来或得一片连续的空间。

另外，垃圾回收时，js 的解析执行就会暂停，所以垃圾回收耗时不能过长，为此还提出了延迟回收、增量式标记、增量式整理、并行标记等算法。

最后，有一种被淘汰的垃圾回收算法——引用计数算法。它给每一个堆内存对象记录它的引用次数，一旦引用次数为 0，那么这个对象就可以被回收了。但是有一个致命问题就是循环引用，比如 A 引用了 B，B 引用了 A，就会造成 A 和 B 的引用次数起码为 1，A、B 对应的堆内存永远无法被回收，造成内存泄漏。

说到内存泄漏，闭包也是一种常见的内存泄漏。

### 2.4 浏览器存储
常见的浏览器存储有三种方式：
第一种 Cookie。Cookie 作为 HTTP 协议的拓展，一般是用来保持状态的。不过因为它可以通过 document.cookie 进行读写，所以也可以用来作为浏览器存储。不过 cookie 的存储上限是 4 KB，一般不会使用它来进行浏览器存储。而且 http-only 设为 true 的 cookie 也是不能用 js 进行读取的。

第二种是 LocalStorage 和 sessionStorage，它们的存储上限是 5 M，比 Cookie 更适合浏览器存储，二者区别：
1. LocalStorage 是长期存储，需要手动清除；SeesionStorage 是会话存储，会话介绍后自动清除。
2. LoaclStorage 可以在同源页面下共享；SeesionStorage 只能在同源且同一标签页下共享

LocalStorage 和 sessionStorage 的优点是存储方便，缺点是键值只能是字符串，存储 json 时需要转义。


第三种是 IndexDB，是一个运行在浏览器的非关系型数据库，没有存储上限，一般来说不低于 250 M，键值对存储，键值可以是二进制数据，异步读写。

另外，Cookie、LocalStorage、sessionStorage、IndexDB，都是支持同源策略的。

### 2.5 事件循环
浏览器用事件循环来处理各种异步回调。事件循环是维护了一个任务队列，任务队列里都是一些待执行的任务，当主线程为空时，就会去读取任务队列里的任务。

任务队列里任务分两类：
1. 宏任务，比如定时器回调、http 回调、DOM 事件回调等
2. 微任务，比如 Promise 的 then 回调

在一轮的事件循环里，执行顺序是：
1. 先执行一个宏任务
2. 再执行全部微任务
3. 判断是否需要重新渲染，需要则重新进行页面渲染

我们在 js 代码里往往会发现，第一个微任务执行得比第一个宏任务要早，但其实不是。因为 script 脚本的加载执行本身也是一个宏任务，本质还是先执行一个宏任务再执行全部微任务。

NodeJS 的事件循环和浏览器的事件循环类似，但也有不同，不同点在于：
1. 宏任务队列分为 6 中，对应事件循环 6 个阶段，而且一次事件循环会执行掉全部的宏任务
2. 微任务的执行时机是一个宏任务队列里的宏任务全部执行完毕后。不过有一个阶段特殊，就是 poll 阶段，它是没执行一个宏任务后就清空一次微任务队列

## 三、js

### 3.1 对象浅拷贝和深拷贝

### 3.2 数组扁平化

### 3.3 模块化
在 ES6 module 之前，浏览器的模块化标准是 AMD，node 的模块化标准是 CommonJS。

AMD 已经被淘汰了，因为它异步加载的方式导致模块依赖关系很难维护。
CommonJS 还有在使用，不过正在逐渐地被 ES6 module 取代。

下面我列举一下 CommonJS 和 ES6 module 的区别:
1. 加载机制的区别：
	- ES6 module 是编译时加载，也叫静态加载。在代码编译的时候就可以分析出模块依赖关系，所以可以结合构建工具比如 webapck 进行 tree-shaking 去除死代码
	- CommonJS 是运行时加载，也叫动态加载。代码执行的时候才能知道具体依赖的是什么模块，所以无法进行 tree-shaking
2. 导出值的不同：
	- CommonJS 的导出值是值的拷贝，对导出值进行读写都不影响模块内部的变量
	- ES6 module 的导出值是指的映射，只读不可写，可以通过导出的其他方法对导出值对应的内部变量进行修改，修改后再读导出值得到的就是新的映射值
3. 顶层 this 的不同
	- ES6 module 默认使用严格模式，所以顶层 this 是 undefined
	- CommonJS 默认没有使用严格模式，所以顶层 this 一般是 window

### 3.4 事件

### 3.5 说一下闭包
闭包的概念是：一个函数，它有权访问另一个函数的作用域。

闭包函数之所以能访问另一个函数的作用域，有两个原因：
1. 作用域链上引用到了另一个函数的 AO 对象。比如在 A 函数里定义了 B函数，B 函数的作用域链上有 A 函数的 AO 对象。
2. 另一个函数的 AO 对象没被销毁。为什么没被销毁，其实就是因为被引用了，无法被回收嘛。

闭包往往会导致另一个函数上的变量对象对应的堆内存无法回收，过度使用会造成内存泄漏。

### 3.6 说一下 this
this 的绑定分为 5 类：
1. 默认绑定：非严格模式下是 window，严格模式下是 undefined
2. 隐式绑定：比如有一个对象去调用了这个函数，那么函数的 this 就执行这个对象
3. 显示绑定：call、bind、apply，可以强制指定一个函数的 this
4. new 绑定：new 本质就是创建了一个空对象，并把 this 作为构造函数的 this 去执行构造函数
5. 箭头函数的 this：箭头函数没有自己的 this，它的 this 取决于外部环境，或者说是它定义时所在的 this

优先级是由 1 → 5 递增的。
### 3.7 call、apply、bind 的模拟
call 和 apply 的模拟思路是：将函数作为方法添加到 call/apply 指定的上下文对象上去调用，调用完毕之后把方法给删除掉。不过要注意三点：
1. 参数
2. 返回值
3. 没有指定上下文对象时，上下文对象是 window；指定的上下文不是对象类型，要转换为基本包装类型。
```js
Function.prototype.call = function(context, ...args) {
	if (!context) context = window;
	if (context instanceof Object == false) context = new Object(context);
	
	context._fun = this;
	let res = context._fun(...args);
	delete _fun;
	return res;
}
```

bind 的模拟核心思路是：返回一个闭包函数，这样闭包函数就可以访问 bind 指定的上下文对象，并通过 call 或 apply 去指定 this 来执行该函数。注意点：
1. 参数和合并，bind 可以传递参数，返回的函数也可以传递函数
2. 没有指定上下文对象时，上下文对象是 window；指定的上下文不是对象类型，要转换为基本包装类型。
3. 因为返回的是一个函数，该函数可以被 new，而 new 的优先级是高于 bind 的，要兼容这一点。
```js
Function.prototype.bind = function (context, ...args1) {
	if (!context) context = window;
	if (context instanceof Object == false) context = new Object(context);
	let fun = this;
	let res_fun = function(...args2) {
		return fun.call(
		this instanceof res_fun ? this : context,
        ...args1, ...args2);
	}
	res_fun.prototype = this.prototype;
	return res_fun;
} 
```
### 3.8 箭头函数和 function 的区别
1. 箭头函数没有自己的 this，function 有
2. 箭头函数没有 argument 对象，function 有
3. 箭头函数没有作为构造函数的 prototype 原型指针，function 有
4. 箭头函数的 this 进行隐式绑定、显示绑定都无效，使用 new 操作符会报错 

### 3.9 作用域
作用域，就是一个函数能访问的变量范围，是和嵌套层级对应链式结构，最前端是自己的 AO 对象，最末尾是全局的 GO 对象。访问一个变量时，就从作用域链不断向上匹配标识符。

一个函数的作用域生成分两个阶段：
1. 函数定义时，会将函数定义所在的作用域链复制到 [[scope]] 内部属性里。
2. 函数执行时，生成自己的 AO 对象，将 AO 对象放到 [[scope]] 作用域链最前端，得到自己的作用域链。

### 3.10 原型
1. 构造函数有 prototype 指针执行原型
2. 原型有 constructor 指针指向构造函数
3. 实例有 \_\_proto\_\_ 指针指向原型

如果一个对象的原型指向了另外一个对象，而另外的对象也存在原型指针，那么，一条关于原型的链式结构就诞生了，称为“原型链”。在一个对象上寻找某个键名时，如果找不到，就会去顺着原型链不断向上地在原型上找。

原型链的尽头是 Object 构造函数的原型，因为这个原型是原型指针指向了 null。

### 3.11 Function 和 Object 的原型关系
- Object 、Function 作为一个实例，它们的原型指针 \_\_proto\_\_  都指向 Function 构造函数的原型 prototype
- Function 作为一个构造函数，它的原型 Function.prototype 是 Object 的实例

```js
// Function 作为一个实例，是 Fuction 的实例
console.log (Function.__proto__ == Function.prototype)  // true
// Object 作为一个实例，是 Fcuntion 的实例
console.log (Object.__proto__ == Function.prototype)  // true
// Fucntion 作为一个构造函数，它的原型是 Object 的实例
console.log (Function.prototype.__proto__ == Object.prototype) // true
```

### 3.12 继承
继承有三个种类：
第一种，原型链继承，就是通过指定子类的原型为父类，进而继承父类的属性和方法。

优点是，实现方法的共享；缺点是，属性也变全部子类所共享的了。

第二种，是借用构造函数继承，通过将父类构造函数的 this 显示绑定为子类实例，再去执行父类构造函数来实现继承。

优点是，能实现属性的私有；缺点是，没有实现方法的共享。

所以提出了将上面两者结合的继承方式——组合继承：
1. 用借用构造函数继承来继承属性
2. 用原型链继承来继承方法

ES6 的 class 继承，其实类似于组合继承：方法通过原型继承，属性则执行 super 函数实现借用构造函数继承。

不过也有一点不同：
1. 组合继承一般是先创建了子类的 this，再用子类的 this 去执行父类构造函数；
2. class 的 super 本质是先创建父类的的 this，再用父类的 this 去执行子类构造函数。

### 3.13 class 继承的 super 关键字
**这个关键字比较特殊，既可以作为构造函数用，也可以作为对象来使用**
1. **作为构造函数：在子类构造函数里调用 super，这里的 super 相当于父类构造函数**
2. **作为对象：**
	1. **在子类方法里，通过 super 去调用父类方法是，super 相对于父类的原型**
	2. **在子类静态方法里使用 super 调用父类静态方法是，super 相对于父类 class**
	3. **在子类方法里通过 super 对某个实例赋值时，super 相当于子类实例，也就是 this**

### 3.14 说一下 class（传统构造函数和 class 的区别）
class 本质是构造函数的一个语法糖，不过它和传统的构造函数有一些区别：
1. class 定义的方法，是不可枚举的；传统构造函数的原型方法是可枚举的
2. class 只能通过 new 操作符来使用；传统构造函数可以通过显示绑定 this 调用 
3. class 不会变量提升；function 构造函数会变量提升
4. class 目前不支持私有属性、方法；传统构造函数是支持在构造函数内部定义私有变量、方法的
5. class 的的继承，是先执行 super 创建父类的 this，再用这个 this 去执行子类的构造函数；而传统构造函数的继承是先生成子类实例的 this，再用这个 this 去执行父类构造函数

再说一下 class 的 super：如上

### 3.15 new 的原理/模拟
new 的模拟流程：
1. 创建一个空对象
2. 将空对象的原型指向构造函数原型
3. 将空对象作为 this 去执行该构造函数
4. 根据构造函数的返回值不同，最后得到的实例也不同：
	1. 返回值是对象，则返回值作为实例
	2. 没有返回值 / 返回值不是对象，则空对象作为实例

### 3.16 模拟 insertAfter 方法
通过 insertBefore 和 appendChild 来模拟：insertAfter 有两个参数，待插入的子节点，和表示插入位置的子节点，insertAfter 就是在位置子节点的后面插入新的子节点，分两类：
1. 插入位置的子节点是最后一个子节点，调用  appendChild 插入新节点
2. 其他情况，获取插入位置子节点的下一个节点，用该子节点来调用 insertBefore 插入新节点

```js
let insertAfter = (newel, target) => {
	let parent = target.parent;
	if (target == parent.lastChild) {
		parent.appendChild(newel);
	} else {
		let next = target.nextSlibing;
		parent.insertBefore(newel, next);
	}
}
```




## 四、vue

### 4.1 MVVM 和 MVC 的区别
MVC 模式，model-view-controller。model 就是数据，view 就是界面，controller 就是逻辑层，负责 model 和 view 之间的数据传递，也就是：
1. 将数据 model 显示在 view 界面上，比如 DOM 操作
2. 从 view 界面上来获取 model 数据，比如 DOM 的事件

但 controller 层不仅仅负责 model 层和 view 层的数据交互，它还有其他很多的业务逻辑，所以 controller 会显得比较臃肿。

所以，提出了 MVVM 模式，将 model 和 view 的间接通信工作抽离了出来，这部分叫 VM。比如 Vue 框架，就是一个典型的 MVVM 框架，将数据修改到 DOM 的更新这部分工作单独抽离出来，作为 VM，这样开发者就不用关心 model 层和 view 层的映射过程，只需要关心对数据的业务逻辑部分。

### 4.2 Vue-Router 的设计原理
1. 路由匹配机制
创建 vue-router 对象的时候，会创建一个匹配器，用来匹配路由对应的组件。本质是将路由指定的路径编译成正则表达式，和当前的路由路径进行正则匹配，将匹配成功的路由组件返回用以渲染。
2. 路由组件的渲染机制
vue-router 内部维护了一个 route 对象，这个对象是一个响应式数据，并收集了渲染函数作为观察者。一旦路由发生修改，route 也会跟着改变，然后就可以触发渲染函数观察者重新渲染新的路由组件。

### 4.3 Vuex 的设计原理
1. Vuex 的数据响应式
Vuex 的 state 和 getter 是响应式的，本质其实创建了一个新的 vue 实例，将 state 作为 data 选项，而 getter 作为计算属性选项来处理，进而去实现两者的响应式，和 vue 项目里的数据响应式进行统一。
2. Vuex 的单向数据流
Vuex 有一个单向数据流的书写规范，就是 state 只能通过同步的 mutation 去修改，异步的 action 只能调用同步的 mutation 去修改 state，而页面则只能通过调用异步的 action 或者同步的 mutation 去修改 state 来改变视图。维护这样一个单向数据流，是有利于追踪到数据改变的调用，让 state 的修改变得可预测。

### 4.4 Vue 组件通信
1. props 和 $emit 进行父子组件通信：父组件通过 props 传递数据到子组件，子组件通过 emit 触发父组件给子组件指定的自定义事件。
2. vue 实例上的 $children、$parent、ref 去访问组件的父子组件，然后可以访问 vue 实例上的 data、方法这些，进而来父子组件通信
3. provide 和 inject：祖先组件通过 provide 提供变量，子孙组件通过 inject 来注入变量，实现跨级组件的通信，不过 provide 和 inject 注入的变量都不是响应式的。
4. $attr 和 $listener：$attr 里面是，没有被子组件识别的 prop，可以继续注入到子组件的子组件里去。$listener 则是父组件给子组件注册的自定义事件，可以记住注入到子组件的子组件里去。进而实现跨级通信。
5. 事件总线。全局维护一个空的 vue 实例，用来注册事件和触发事件，其他组件通过使用事件总线的事件流来进行通信，可以实现父子、跨级、兄弟组件通信。不过，当项目大型起来，事件总线就很难维护了，所以事件总线比较适合小型项目
6. Vuex。Vuex 本质也是创建一个 vue 实例，用来将 state 处理成响应式的。vuex 有一个单向数据流的规范，用以方便梳理状态修改的来源。vuex 适合一些中大型项目，对于小型项目而言有点大材小用。

### 4.5 Vue 响应式系统原理
Vue 的响应式系统分为三个部分：
1. 追踪数据变化。
2. 观察者 → 收集观察者和触发观察者
3. 异步队列 → 去重

### 4.6 观察者-订阅者模式

### 4.6 Vue 虚拟 DOM 的 diff 算法
diff 算法，是 vue 使用新旧 vnode 进行 petch 打补丁时使用的。

petch 对比的前提是，新旧 vnode 描述的是同一个 DOM 节点，什么叫描述同一个 DOM 节点呢，就是新旧 vnode 的 key 一样、标签一样、如果是 input 标签的话它们的 type 一样等等。如果新旧 vnode 描述的不是同一个 vnode 了，那么直接移除旧的 DOM，用新 vnode 生成新的 DOM 插入到条页面里去。

如果描述的是同一个 DOM，那么就会去更新它的属性啊、样式啊、事件的这些。最关键的，是更新子节点列表，这也是 diff 算法的核心。

更新子节点列表时，首先使用双端比较，就是判断新旧子节点 vnode 双端是否描述同一个 DOM，如果是的话，则可以复用 DOM 节点。双端比较失败后，会使用旧子节点 vnode 列表的 key 和数组下标创建一个哈希表，本质也是给新子节点 vnode 来判断是否存在可以复用的旧 vnode，以减少 DOM 操作。

特别是对于 v-for 子节点而言，子节点使用的都是同一个模板，区别只在于 key。

一旦使用 index 为 key，那么每次更新 v-for 都会按照下标来进行 petch 更新。这种是使用场景是列表的页码切换。

如果使用唯一 id 作为 key，那么更新 v-for 数组时，会使用 key 来进行最大程度的 DOM 节点复用。比如 v-for 数组只是将头元素放到了末尾，那么双端比较就可以判断出来，只调用一次 insertBefore 去修改 DOM 位置，其他的节点全部可以复用。这种情况适合对同一个列表进行多种排序时使用，比如将同一份成绩列举从大到小排序切换到按班级排序。

### 4.7 Vnode 的意义
1. 跨平台。不同的平台下的渲染层实现可能不同，但是可以向上抽离成相同的 vnode 描述，向下再兼容不同的平台渲染方法，实现跨平台的开发。
2. 用 js 计算性能换取 DOM 操作性能。我们知道 DOM 操作是比较消耗性能的，通过 diff 算法来计算出尽可能少的 DOM 操作，避免不必要的 DOM 操作，当然这个 diff 算法计算出的 DOM 操作有时候可能也不是最优的。

### 4.8 计算属性的实现
vue 里计算属性比较特殊，它既是一个响应式数据可以收集其他观察者为依赖，同时它也是一个观察者可以被其他响应式数据收集。

当计算属性依赖的响应式数据修改时，会触发计算属性观察者，但是计算属性不会立刻重新求值，而是将自己标记为是需要重新求值的，然后，它会去触发它自己收集的观察者，这些观察者被触发后，会进行更新，然后重新对计算属性求值，这时候计算属性才会开始重新求值。

## 五、微信小程序

### 5.1 微信小程序和 H5 应用的区别
第一，微信小程序的双线程
两者之间最大的区别应该在于底层模型。传统的 H5 页面里，js 引擎线程和 GUI 渲染线程是互斥的。而在微信小程序里，逻辑层线程和渲染层线程是并行，二者之间通过客户端进行中转通信。

第二，为什么提出双线程
1. 为了快。微信小程序使用双线程模型的目的是就是快，并行的双线程避免了 H5 应用里的线程互斥造成渲染阻塞，所以可以拥有更好的渲染性能。
2. 为了管控和安全。传统的 web 技术，可以进行跳页面、操作DOM 之类的，但这些在小程序里都是不允许的，为什么呢，就是为了管控和安全。因为小程序里有一些组件比如 open-data，只负责展示用户的数据，但不能被 js 拿到，因为有一些数据属于用户隐私。但如果可以进行 DOM 操作的话，这些数据是肯定可以拿到的。所以微信小程序通过客户端自带的 js 引擎去创建了一个 js 线程，这个 js 线程只负责纯 js 代码的解析执行。

第三，双线程的缺点
因为是逻辑层和渲染层并行，二者之间还通过客户端进行中转通信，所以肯定会存在延时问题。也就是说，逻辑层已经把数据给修改了，但是渲染层可能还没有开始渲染。

因此我们可以发现，小程序的大部分 API 都是设计成异步的。

### 5.2 微信登录
1. 小程序调用 wx.login() 请求临时 code，将 code 发送给开发者后台
2. 开发者后台用 code、appid、appSecret 向微信服务端请求用户的 opendid，然后将 openid 和业务 id 联系起来，返回对应的用户信息/登录token 给小程序
3. 小程序最后就可以拿到用户信息或登录 token

### 5.3 原生组件
微信内置组件里，存在一些组件是使用客户端进行渲染的，这部分组件叫原生组件。原生组件的原理是，在 DOM 里面插入一个占位元素，然后在占位元素上用一个原生界面去渲染内容。这个原生界面的层级比其他的 DOM 节点都要高。

原生组件的优点：
1. 渲染性能更好，因为使用了客户端渲染。
2. 时延更低，因为原生组件在逻辑层里有 context 上下文对象，通过 context 对数据进行修改后，通过客户端中转后直接传入组件。

原生组件的缺点：
1. 因为使用客户端渲染，一些 css 样式是失效的
2. 原生组件的层级比全部 DOM 原生都要高

## 六、微前端

### 6.1 什么是微前端
当前，单页面应用是一种比较主流的前端项目形态，但是单页面应用往往随着功能的拓展和开发人员的增大，变得越来越难以维护，往往该一处而动全身。也就是所谓的“巨石应用”。

为此，提出了微前端这个架构理念，也就是将一个前端应用拆分成多个细粒度更低的微应用，微应用可以独立开发、测试、部署的微应用，且互不影响。

微前端，具有四个核心价值：
1. 技术栈无关。不同的微应用可以使用不同的技术栈
2. 独立开发、测试、部署。每一个微应用都是独立且成熟的产品，可以进行独立的开发、测试、部署。
3. 增量式升级。微应用之间相互独立，所以我们可以选择逐个微应用的进行升级，实现主应用的渐进式升级。
4. 独立运行时。没有微应用之间状态隔离，运行时状态不共享。

### 6.2 qiankun 的设计原理

qiankun 的设计原理，可以分为三大点：
1. 微应用之间的切换
2. 隔离
3. 通信

第一点，微应用之间的切换。qiankun 采取的是路由分发策略，将不同的路由和不同的微应用绑定起来，一旦 url 发送变化，就触发路由匹配，渲染对应路由的微应用。关键的切换函数是内部的一个 loadApp  方法。

第二点，就是隔离，分为 js 隔离和 css 隔离。
css 隔离的话，是给微应用的 DOM 外部套一个 shadow DOM，利用 shadow DOM 的隔离性来实现 css 隔离。
js 隔离的话，是通过创建 js 沙箱，限制 js 对 window 的访问的和修改。js 沙箱分三类：
1. 快照沙箱，不支持 Proxy 的浏览器的兼容版本。本质是用两个对象记录上微应用加载前和卸载前的 window，用来还原 window → 前者是还原主应用 window，后者是还原微应用 window。这个隔离方式比较简单，如果同时运行多个微应用，可能会出错。
2. 用 proxy 去拦截到微应用 js 脚本对 window 的访问，以此来维护三个状态池，也是和快照沙箱类似，本质记录微应用加载前和卸载前的状态，最后去还原 window。这个隔离方式也不适合同时运行多个微应用。
3. 也使用了 proxy 去拦截微应用 js 脚本对 window 的访问，不同的是，它将对 window 的操作都引向另一个对象，这个对象是 window 的一个复制，所以不会影响到 window 本身。这种隔离方式比较合理，可以同时运行多个微应用。


第三点就是，微应用之间的通信。
微应用之间应该尽量减少通信，以降低耦合性。但有的时候需要必要的通信。

qiankun 提供一种叫 action 通信的机制让微应用之间可以通信。这个通信机制采取的观察者模式。

它在全局维护了一个 globalState 对象，然后微应用或主应用可以注册观察者，观察者会统一放到一个观察者池里面去。当有微应用或主应用可以去修改 globalState，进而触发观察者池里全部的观察者。

### 6.3 为什么微前端不使用 iframe
iframe 是天生完美隔离的容器，但它最大的缺点也就是它的隔离性很难甚至无法突破：

1. iframe 的通信问题。iframe 之间只能通过 postMessage  或自己的 window 对象来进行通信，比较局限不够灵活。
2. iframe 的样式问题。比如我在 iframe 里想弹出一个全局的遮罩，但是因为 iframe，所以这个遮罩只会盖住 iframe 本身。
3. iframe 的性能问题。onload 事件必须等待全部 iframe 加载完毕才能触发，影响主页加载。

## 七、webpack

### 7.1 webpack 构建原理

webpack 构建，就是将一个项目工程里复杂的模块依赖关系进行处理，最后输出一个或几个构建结果。另外 webpack 还把整个构建过程暴露出来，让开发者可以通过 loader 或 plugin 去参与构建过程来执行一些自定义的拓展功能。

webpack 的构建过程如下：
首先，解析命令行指定的和配置文件（webpack.config.js）指定的配置性参数，来获取初始的配置项。
然后，正式编译。从 entry 入口开始，用 loader 将文件转义成 webpack 可以识别的模块，并对其依赖的模块进行递归的解析，这样最后就能得到整个模块依赖树，并生成对应的 chunk 代码块，最后对这个 chunk 代码块进行打包构建，将最后的构建结果输入到文件系统。 

### 7.2 常见 loader
loader 本质是一个函数，用来对文件转义成 webpack 可识别的模块，因为 webpack 只能识别 js 和 json 文件。因为 loader 的存在，webpack 才拥有 “一切皆模块” 的思想。

比如有一个 sass 文件，首先会使用 sass-loader 把它转义成一个 css 文件，再用 css-loader 把 css 文件转义成一段 js 字符串，最后用 style-loader 这段字符串转义成一段代码，这段代码就是用来把 css 插入到 html 里面去的。可以看到最后把 sass 文件转义成一段 js 代码，这段 js 代码 webpack 自然能识别并且进行模块依赖分析的。

常见 loader：
1. babel-loader：将 es6 转义成 es5
2. ts-loader：编译 ts
3. vue-loader：处理 .vue 文件，将 template、js、样式进行分离
4. vue-template-complier：对 complier 进行模板编译。

### 7.3 常见 plugin

webpack 会把构建过程暴露出一些事件钩子，插件会注册对应事件钩子的回调，然后在构建过程特定的时刻里执行自定义的代码，对 webpack 功能进行拓展。

常见的插件，有压缩 js 代码的 uglifyjs-webpack-plugin，用来代码分片的 split-chunks-plugin。

### 7.4 代码分片

使用 webpack 打包后，可能得到单独一个很大的 js 文件。我们知道，js 的解析执行会阻塞渲染线程的及时渲染，所以我们下载一个很大的 js 文件可能会导致首页白屏。

所以，就需要代码分片。代码分片本质是将项目里公共的模块提取出来，作为单独的构建输出。这样有什么好处呢：
1. 提取公共模块，避免公共模块的重复构建，减少整体构建资源的大小
2. 公共模块是很少进行 修改的，所以可以很好利用客户端缓存能力
3. 多个构建文件的下载，可以利用浏览器的并行下载能力
4. 结合异步加载的形式，可以实现资源的按需加载，而不是一次加载全部资源导致首页白屏

#### 7.5 tree-shaking
tree-shaking，去除死代码。什么叫死代码，就是在一个项目工程里引入了一个模块，但是没有任何的其他模块去引用它，所以这个模块也就是无用模块，也叫死代码。

tree-shaking 本质就是给死代码添加标记，然后通过压缩工具去移除死代码，以减少最后的构建体积。

tree-shaking 有两个注意点：
1. 模块必须是 ES6 module。因为 ES6 module 是静态加载，在代码编译时就能分析出模块依赖关系，以便查出那些模块属于“死代码”
2. 禁用 babel-loader 对 ES6 module 语法的转义，不然它会把 ES6 module 转义成 CommonJS，导致无法 tree-shaking

### 7.6 HMR 热更新 
热更新就是修改代码后，不需要手动刷新浏览器，页面会自带更新修改后的状态。

原理是：
1. 本地搭建一个服务，和前端页面建立 websocket 连接，一旦本地资源有修改，就向前端页面推送更新事件，并附带更新的 hash 值
2. 前端页面判断这个 hash 值来决定要不要进行更新。如果需要，则向本地服务发起 jsonp 的拉取资源更新请求。

至于前端页面是怎么建立 websocket 连接，是因为 webpack 构建时，混入一个特殊的入口文件，这个入口文件会导致最后的构建结果里有一段特殊的段代码，这段代码就是用来开启 websocket 的。

## 八、项目

### 8.1 QG招新网

#### 8.1.1 介绍项目
这是一个纯前端项目，主要用以介绍和宣传工作室，里面运用到一些技巧对项目进行了优化。
1. 压缩资源。我用字蛛对字体包进行了压缩，然后对图片也进行了无损压缩，还有把除了 html 以外的静态资源全部挂载到 oss 上去，大大加快的首屏加载的时间。在没有进行这些优化之前，我的首屏大概有不到 1 s 的白屏，优化后，白屏不到 0.2 s。
2. 我使用了 requestAnimationFrame 请求动画帧的 api 改写了定时器动画，requestAnimationFrame 注册的回调是在每一帧的渲染之前执行的，所以可以更好地控制每一帧的渲染。
3. 使用 css3 属性去开启 GPU 硬件加速，这个在手机端效果比较明显。
4. 使用 web worker 进行 js 线程计算任务的分离。这个其实在我的这个项目里效果不是特别明显，因为我的 js 线程并没有涉及到太多的纯逻辑任务。不过我在另一个项目里有使用过这个用以优化渲染，那个项目是对一份比较大的数据进行多维度的图表展示，因为种种原因，后台没有帮我计算这些图表需要的数据，后台只给了我原始的数据，我需要用这些原始数据进行计算得到最后展示的数据，所以我给每一类图表都开了一个子线程去计算图表数据。最后的图表初始化速度没有提高多少，但是图表切换很快，因为多个图表是多个 web worker 子线程并行计算的。



### 8.2 “未闻花名”小程序

#### 8.2.1 虚拟滚动的原理
前景：长列表渲染造成首屏白屏，且滚动会不流畅。

原理：只有滚动视区部分是真实渲染的，而滚动视区上方和下方都是用来撑开高度的空白 DOM，通过监听的滚动事件，来计算上下要填充的高度和真实要渲染的滚动视区内容。



### 8.3 构建民航业知识图谱并实现语义查询

前端页面要求展示的知识图谱是树状的，所以可以用一段 json 对象去描述它。我然后我拦截了这段 json 对象里的添加和移除一个子对象的操作，并用对应的 d3 操作在页面上添加和移除对应 DOM 节点。

关键点的话，有两个：
1. svg DOM 节点和 json 对象的联系。一开始思路有点赌，一直在二者的联系怎么查找比较快，甚至想用算法，后面才想明白，两个都是对象，直接放两个指针相互引用就行了。
2. proxy 的递归吧，比如我给知识图谱里某一个节点创建子节点的时候，对应的 json 对象也会创建一个子对象，我还需要吧这个子对象也处理成 proxy 并引用，类似的，移除的时候也是需要移除 proxy 代理和对应子对象的。

整体来说，项目难度不大，更多的是对 proxy 代理的理解吧。

## 九、css + html
