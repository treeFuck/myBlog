# 小程序

> 参考文档：
> [小程序开发指南](https://developers.weixin.qq.com/ebook?action=get_post_info)
> [小程序开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)

## 一、小程序介绍
### 1.1 小程序与普通网页开发的区别
在浏览器内核里，JS 引擎线程和 GUI 渲染线程是互斥的。因为 JS 线程可以操作 DOM，所以两个线程如果并行，JS 线程一边修改 DOM，GUI 渲染一边依赖 DOM 去渲染，二者可能产生冲突而导致意想不到的错误。

而在小程序中，JS 线程和渲染线程是并行的，不过小程序的 JS 线程不能直接操作 DOM，只能修改数据，数据被修改后会触发页面重新渲染。换句话说，小程序的逻辑层和渲染层是分开来独立并行的。

> 以上是两者程序逻辑设计上的最大区别。
> 另外，还有两者运行环境、开发流程、网络协议等方面上也存在差异，这里略过。

### 1.2 小程序的兼容
和传统 web 页面考虑多个浏览器兼容类似，小程序也要考虑兼容问题。不过小程序的兼容数量不多，只有三种：
1. IOS 微信客户端
2. Android 微信客户端
3. 小程序开发者工具

以下是三种环境下小程序的渲染层、逻辑层环境：

|     运行环境     |     逻辑层     |     渲染层     |
| :--------------: | :------------: | :------------: |
|       IOS        | JavaScriptCore |   WKWebView    |
|       安卓       |   X5 JSCore    |    X5浏览器    |
| 小程序开发者工具 |      NWJS      | Chrome WebView |

## 二、代码相关

### 2.1 rpx 尺寸单位
在小程序的 wxss 里，引入 **rpx 尺寸单位，将屏幕宽度分为 750 份，1份就是 1rpx，最大是 750 rpx，以此来适配不同宽度的屏幕**。

小程序编译后，会将 rpx 换算成 px，换算规则为：`1 rpx = （屏幕宽度 / 750）px `

> 在 iPhone6 里，屏幕逻辑像素宽度为 375 px，对应的物理像素是 750 px。
> 那么 iPhone6 的 1rpx = 0.5px = 1 个物理像素。所以设计师一般用 iPhone6 作为视觉设计稿。

### 2.2 js 作用域与模块化

和浏览器下全部 js 脚本共享一个作用域不同，**小程序里每一个 js 文件都拥有自己的作用域**，互不干扰。

所以，小程序的 js 文件自成模块，另外还可以**使用类似 CommonJS 的语法导出模块和引入其他模块**。
```js
// 导出 a.js
module.exports = ()=>console.log('a.js');

// 引用 a.js
require('a.js')
```

如果要使用**全局变量**，需要**通过全局函数 getApp() 获取小程序实例** ，再对小程序示例上的属性进行读写来达到全局变量的效果。
```js
// a.js
var global = getApp();
global.a = '1111';

// b.js
var global = getApp();
console.log(global.a);
```
在上例中，需要注意的是 a.js 的加载必须在 b.js 之前。

## 三、小程序宿主环境
### 3.1 渲染层和逻辑层
小程序分独立运行的渲染层和逻辑层：
- **渲染层：wxml 和 wxss 工作在 WebView 线程，一个界面对应一个 WebView 线程。**
- **逻辑层：js 脚本工作在 JsCore 线程。**  

**渲染层和逻辑层通过微信客户端（Native）作为中转进行通信**。逻辑层发送的网络请求也由 Native 转发。
![](./img/渲染层和逻辑层通信模型.png)

小程序的 UI 更新是基于“**数据驱动**”模型：
数据修改 → 生成新的 Vnode → diff Vnode 对比差异 → petch diff 更新差异 → UI 更新

### 3.2 程序与页面

#### 3.2.1 程序

重点：
1. 全局变量
2. 生命周期

#### 3.2.2 页面

重点：
1. 生命周期
2. 路由


### 3.3 兼容
通过 wx.getSystemInfoSync() 获取宿主环境信息，针对这些信息做平台差异化处理。返回值如下：
```js
{
	brand: "iPhone",      // 手机品牌
    model: "iPhone 6",    // 手机型号
    platform: "ios",      // 客户端平台
    system: "iOS 9.3.4",  // 操作系统版本
    version: "6.5.23",    // 微信版本号
    SDKVersion: "1.7.0",  // 小程序基础库版本
    language: "zh_CN",    // 微信设置的语言
    pixelRatio: 2,        // 设备像素比
    screenWidth: 667,    // 屏幕宽度
    screenHeight: 375,     // 屏幕高度
    windowWidth: 667,    // 可使用窗口宽度
    windowHeight: 375,     // 可使用窗口高度
    fontSizeSetting: 16   // 用户字体大小设置
}
```
## 四、场景应用
### 4.1 微信登录

### 4.2 本地缓存

## 五、底层框架

### 5.1 双线程模型
#### 5.1.1 技术选型
**微信小程序的架构设计要求只有一个，快，包括要渲染快、加载快。**

一般来说，渲染界面的技术选型有三种：
1. 纯客户端技术
2. 纯 web 技术
3. 前两种的结合，统称 Hybrid 技术

首先，纯客户端技术。小程序的开放性注定它的代码是频繁修改的，不可能随着客户端代码一起进行稳定的版本迭代。小程序的代码资源应该是存放在云端，通过拉取到本地来解析运行。

然后，纯 Web 技术。Web 架构里，js 引擎线程和 GUI 渲染线程是互斥的，逻辑层的运行必定阻塞渲染层的运行，不符合小程序架构要求—— 快。

第三种，Hybrid 技术。比如 React Native， js 脚本负责逻辑任务，渲染任务则交给客户端。但客户端来渲染会带来一些问题，最后放弃了类 React Native 的模型。最终，**微信小程序依旧选择了类似 JS-SDK 的 Hybrid  模型**，即将渲染交给 Web 技术，并配合一些接口去调用封装好的客户端操作。不过，依旧存在一些内置组件采取客户端渲染，目的是为了更好的性能。

#### 5.2.2 管控与安全
**使用纯 web 技术渲染小程序存在一些不可控因素和安全风险**，比如：

1. js 脚本可以随意跳转页面。这样小程序本身就失去了意义。
2. js 脚本可以操作 DOM。小程序存在一些用以展示敏感数据的组件，这些数据是希望只被展示而不被 js 读取到的，但如果可以操作 DOM，这些数据也就可以轻易拿到而失去安全性。

综上所述，我们**需要提供一个只解析执行纯 js 的沙箱环境**。 所幸，微信客户端自带 js 的解析引擎(iOS 下是 JavaScriptCore 框架，安卓是腾讯 x5 内核提供的 JsCore 环境)，可以创建一个单独的 js 线程去运行小程序的 js 脚本。

另外，通过给 js 线程创建沙箱运行环境，隔离了渲染层和逻辑的层的运行，所以还需要微信客户端作为两者独立运行的通信中转。

以上，就是微信小程序双线程模型的提出。

#### 5.2.3 天生的延时
传统的 web 页面，js 引擎线程和 GUI 渲染线程是互斥的，js 线程修改完数据后，GUI 渲染线程会将新的数据状态更新到 UI 上。

但在微信小程序里，渲染层线程和逻辑层线程是并行执行的，并且二者的通信经过了客户端主线程作为中转，所以是肯定存在时延的。也就是说，可能逻辑层数据已经成功修改了，但渲染层还没有开始更新 UI。

### 5.2 组件系统

### 5.3 原生组件

### 5.4 小程序与客户端通信原理


