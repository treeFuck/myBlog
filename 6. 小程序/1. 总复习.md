# 小程序

> 参考文档：
> [小程序开发指南](https://developers.weixin.qq.com/ebook?action=get_post_info)
> [小程序开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)

## 一、小程序介绍
### 1.1 小程序与普通网页开发的区别
在浏览器内核里，JS 引擎线程和 GUI 渲染线程是互斥的。因为 JS 线程可以操作 DOM，所以两个线程如果并行，JS 线程一边修改 DOM，GUI 渲染一边依赖 DOM 去渲染，二者可能产生冲突而导致意想不到的错误。

而在小程序中，JS 线程和渲染线程是并行的，不过小程序的 JS 线程不能直接操作 DOM，只能修改数据，数据被修改后会触发页面重新渲染。换句话说，小程序的逻辑层和渲染层是分开来独立并行的。

> 以上是两者程序逻辑设计上的最大区别。
> 另外，还有两者运行环境、开发流程、网络协议等方面上也存在差异，这里略过。

### 1.2 小程序的兼容
和传统 web 页面考虑多个浏览器兼容类似，小程序也要考虑兼容问题。不过小程序的兼容数量不多，只有三种：
1. IOS 微信客户端
2. Android 微信客户端
3. 小程序开发者工具

以下是三种环境下小程序的渲染层、逻辑层环境：

|     运行环境     |     逻辑层     |     渲染层     |
| :--------------: | :------------: | :------------: |
|       IOS        | JavaScriptCore |   WKWebView    |
|       安卓       |   X5 JSCore    |    X5浏览器    |
| 小程序开发者工具 |      NWJS      | Chrome WebView |

## 二、代码相关

### 2.1 rpx 尺寸单位
在小程序的 wxss 里，引入 **rpx 尺寸单位，将屏幕宽度分为 750 份，1份就是 1rpx，最大是 750 rpx，以此来适配不同宽度的屏幕**。

小程序编译后，会将 rpx 换算成 px，换算规则为：`1 rpx = （屏幕宽度 / 750）px `

> 在 iPhone6 里，屏幕逻辑像素宽度为 375 px，对应的物理像素是 750 px。
> 那么 iPhone6 的 1rpx = 0.5px = 1 个物理像素。所以设计师一般用 iPhone6 作为视觉设计稿。

### 2.2 js 作用域与模块化

和浏览器下全部 js 脚本共享一个作用域不同，**小程序里每一个 js 文件都拥有自己的作用域**，互不干扰。

所以，小程序的 js 文件自成模块，另外还可以**使用类似 CommonJS 的语法导出模块和引入其他模块**。
```js
// 导出 a.js
module.exports = ()=>console.log('a.js');

// 引用 a.js
require('a.js')
```

如果要使用**全局变量**，需要**通过全局函数 getApp() 获取小程序实例** ，再对小程序示例上的属性进行读写来达到全局变量的效果。
```js
// a.js
var global = getApp();
global.a = '1111';

// b.js
var global = getApp();
console.log(global.a);
```
在上例中，需要注意的是 a.js 的加载必须在 b.js 之前。

## 三、小程序宿主环境
### 3.1 渲染层和逻辑层
小程序分独立运行的渲染层和逻辑层：
- **渲染层：wxml 和 wxss 工作在 WebView 线程，一个界面对应一个 WebView 线程。**
- **逻辑层：js 脚本工作在 JsCore 线程。**  

**渲染层和逻辑层通过微信客户端（Native）作为中转进行通信**。逻辑层发送的网络请求也由 Native 转发。
![](./img/渲染层和逻辑层通信模型.png)

小程序的 UI 更新是基于“**数据驱动**”模型：
数据修改 → 生成新的 Vnode → diff Vnode 对比差异 → petch diff 更新差异 → UI 更新

### 3.2 程序与页面

#### 3.2.1 程序
##### 1. 全局变量
App() 构造器创建了小程序实例 app，页面 page 之间通过 getApp() 获取小程序实例后再进行属性读写，来实现全局变量。

##### 2. 小程序生命周期
- onLaunch：小程序初始化完毕，之后触发一次
- onShow：小程序启动 / 小程序从后台切入前台时触发
- onHide：小程序从前台切入后台时触发
- onError：小程序脚本错误 / API 调用错误时触发，参数上附带错误信息

#### 3.2.2 页面

##### 1. 页面生命周期
1. onLoad：页面正在加载，最早被触发的生命周期，在 page 销毁前只触发一次
2. onShow：页面显示时触发，第一次触发会早于 onReady
3. onReady：页面初次渲染完毕触发，晚于第一次的 onShow，在 page 销毁前只触发一次。
4. onHide：页面被隐藏时触发
5. onUnload：页面卸载时触发

##### 2. 页面路由切换
小程序的页面栈最大层级为 10 层。

页面分两类：
1. Tabbar 页面：被移除页面栈后不会销毁，只触发 onHide 生命周期
2. 非 Tabbar 页面：被移除页面栈后会销毁，触发 onUnload 生命周期

路由切换方法：
1. wx.navigateTo：打开新的**非 Tabbar 页面** → 新页面入页面栈
2. wx.navigateBack：返回上一个页面 → 移除页面栈栈顶
3. wx.redirectTo：重定向到一个**非 Tabbar 页面** → 页面栈顶替换为新页面
4. wx.switchTab：打开新的 **Tabbar 页面** → 清空页面栈，并将新页面入栈

### 3.3 兼容
通过 wx.getSystemInfoSync() 获取宿主环境信息，针对这些信息做平台差异化处理。返回值如下：
```js
{
	brand: "iPhone",      // 手机品牌
    model: "iPhone 6",    // 手机型号
    platform: "ios",      // 客户端平台
    system: "iOS 9.3.4",  // 操作系统版本
    version: "6.5.23",    // 微信版本号
    SDKVersion: "1.7.0",  // 小程序基础库版本
    language: "zh_CN",    // 微信设置的语言
    pixelRatio: 2,        // 设备像素比
    screenWidth: 667,    // 屏幕宽度
    screenHeight: 375,     // 屏幕高度
    windowWidth: 667,    // 可使用窗口宽度
    windowHeight: 375,     // 可使用窗口高度
    fontSizeSetting: 16   // 用户字体大小设置
}
```
## 四、场景应用
### 4.1 微信登录
如图：
![](./img/微信登录.png)

登录流程分析：
1. 小程序发起登录，通过 wx.login() 向微信服务器请求一个临时 code 作为身份凭证，code 有效期是 5 分钟。
2. 小程序将 code 发送到开发者服务器。
3. 开发者服务器用 **code、AppId、AppSecret** 向微信服务器请求小程序用户信息。微信服务端返回用户 openid 和 session_key，并让 code 失效。
	- **openid** 用以表示唯一的微信用户
	- **session_key** 作为后续开发者服务器向微信服务器发起请求的会话密钥
4. 开发者服务器用 openid 和业务用户 id 联系起来，生成业务登录凭证 SessionId 并返回给小程序。
5. 小程序拿到 SessionId 后，后续的请求都带上 SessionId 表示已登录。

### 4.2 本地缓存
小程序提供读写缓存的 api：
1. 读取缓存：
	- 异步 wx.getStorage 
	- 同步 wx.getStorageSync
2. 写入缓存
	- 异步 wx.setStorage
	- 同步 wx.setStorageSync

缓存隔离：不同用户之间、不同小程序之间的缓存，都存在隔离

缓存上限：每个小程序缓存空间上限为 10 M，如果缓存已经达到上限，再通过wx.setStorage / wx.setStorageSync 写入缓存会触发 fail 回调。 

场景应用：缓存用户登录态 SessionId，并指定缓存的过期时间，可以维持登录态。

## 五、底层框架

### 5.1 双线程模型
#### 5.1.1 技术选型
**微信小程序的架构设计要求只有一个，快，包括要渲染快、加载快。**

一般来说，渲染界面的技术选型有三种：
1. 纯客户端技术
2. 纯 web 技术
3. 前两种的结合，统称 Hybrid 技术

首先，纯客户端技术。小程序的开放性注定它的代码是频繁修改的，不可能随着客户端代码一起进行稳定的版本迭代。小程序的代码资源应该是存放在云端，通过拉取到本地来解析运行。

然后，纯 Web 技术。Web 架构里，js 引擎线程和 GUI 渲染线程是互斥的，逻辑层的运行必定阻塞渲染层的运行，不符合小程序架构要求—— 快。

第三种，Hybrid 技术。比如 React Native， js 脚本负责逻辑任务，渲染任务则交给客户端。但客户端来渲染会带来一些问题，最后放弃了类 React Native 的模型。最终，**微信小程序依旧选择了类似 JS-SDK 的 Hybrid  模型**，即将渲染交给 Web 技术，并配合一些接口去调用封装好的客户端操作。不过，依旧存在一些内置组件采取客户端渲染，目的是为了更好的性能。

#### 5.1.2 管控与安全
**使用纯 web 技术渲染小程序存在一些不可控因素和安全风险**，比如：

1. js 脚本可以随意跳转页面。这样小程序本身就失去了意义。
2. js 脚本可以操作 DOM。小程序存在一些用以展示敏感数据的组件，这些数据是希望只被展示而不被 js 读取到的，但如果可以操作 DOM，这些数据也就可以轻易拿到而失去安全性。

综上所述，我们**需要提供一个只解析执行纯 js 的沙箱环境**。 所幸，微信客户端自带 js 的解析引擎(iOS 下是 JavaScriptCore 框架，安卓是腾讯 x5 内核提供的 JsCore 环境)，可以创建一个单独的 js 线程去运行小程序的 js 脚本。

另外，通过给 js 线程创建沙箱运行环境，隔离了渲染层和逻辑的层的运行，所以还需要微信客户端作为两者独立运行的通信中转。

以上，就是微信小程序双线程模型的提出。

#### 5.1.3 天生的延时
传统的 web 页面，js 引擎线程和 GUI 渲染线程是互斥的，js 线程修改完数据后，GUI 渲染线程会将新的数据状态更新到 UI 上。

但在微信小程序里，渲染层线程和逻辑层线程是并行执行的，并且二者的通信经过了客户端主线程作为中转，所以是肯定存在时延的。也就是说，可能逻辑层数据已经成功修改了，但渲染层还没有开始更新 UI。

#### 5.1.4 总结
**1. 简要说明双线程模型**
渲染层线程和逻辑层线程并行，二者通过客户端线程进行中转通信。

渲染层使用的 webView 线程，一个小程序页面拥有一个 webView 线程。
逻辑层线程只有一个，来自客户端自带的 js 引擎。(iOS 下是 JavaScriptCore 框架，安卓是腾讯 x5 内核提供的 JsCore 环境)

**2. 为什么提出双线程模型**

1. 为了快。传统 web 页面里 js 引擎线程和 GUI 渲染线程是互斥的，也就是  js 的执行会阻塞渲染的进行，而小程序的双线程则是逻辑层线程和渲染层线程的并行执行，比起传统 web 的线程互斥会有快的渲染性能。
2. 为了管控和安全。传统 web 的 js 非常开放灵活，比如可以进行页面跳转和 DOM 操作等，但这些操作在小程序里存在一定的安全风险（比如小程序的 open-data 组件是展示微信开放的数据，但是里面有一些隐私数据是不希望被 js 直接读取到的，但如果可以进行 DOM 操作，这些数据的安全性就失去了意义）。说白了，就是小程序希望限制 js 的执行能力，希望 js 线程只负责纯 js 语法的解析执行，为此，用微信客户端的内置 js 引擎创建了新的 js 线程用以解析执行 js 脚本。

**3. 双线程模型有什么缺点**
时延问题。渲染层和逻辑层的并行，所以两者通信需要客户端中转，所以会产生 ”逻辑层已经修改了数据，但渲染层还没开始更新 UI“ 这种时延问题。

所以，为了处理天生的时延，小程序的大多数 API 都设计成了异步。

### 5.2 组件系统
小程序基于 Exparser 框架，内置了一套组件以涵盖小程序基本功能，并提供自定义组件开发功能。

Exparser 的组件模型与 WebComponents 标准中的 ShadowDOM 高度相似。

#### 5.2.1 ShadowTree 和 Composed Tree
组件内部的节点树，称为 ShadowTree。
最终拼接成的页面节点树，称为 Composed Tree。

```html
<!-- 调用组件的节点树 --> 
<view>
    <input-with-label>TEXT</input-with-label>
</view>

<!-- input-with-label 的 Shadow Tree --> 
<label><slot/></label>
<input />

<!-- 页面节点树 Composed Tree --> 
<view>
  <input-with-label>
    <label>TEXT</label>
    <input />
  </input-with-label>
</view>
```
Page 构造函数创建的也是一个组件，页面根组件。

#### 5.2.2 组件的事件冒泡
如下例：
```html
<view>
  <input-with-label>
    <button />
  </input-with-label>
</view>
```
如果在 button 触发一个事件：
1. 如果事件非冒泡，那么只能在 button 上监听到事件
2. 如果事件在 Shadow Tree 上冒泡，则触发顺序为 button → input-with-label → view 
3. 如果事件在 Composed Tree 上冒泡，则触发顺序为 button → slot  → label →  input-with-label → view 

在自定义组件中使用 triggerEvent 触发事件时，可以指定事件的 bubbles、composed 和capturePhas e属性，用于标注事件的冒泡性质。

```js
this.triggerEvent('hello', {}, {
	bubbles: true,      // 这是一个冒泡事件
	composed: true,     // 这个事件在 Composed Tree 上冒泡
	capturePhase: false // 这个事件没有捕获阶段
})
```

### 5.3 原生组件
在内置组件中，有一些组件较为特殊，它们并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染，这类组件我们称为“原生组件”，这也是小程序 Hybrid 技术的一个应用。

原生组件的渲染过程大致如下：
1. webView 线程创建一个占位元素插入要 DOM 树里
2. 客户端在占位元素上叠加一层原生界面，渲染特殊的内容，比如 video、map、canvas 等

值得注意的是，原生组件的内容渲染依靠的是原生界面，而原生界面的渲染层级会比所有在 WebView 层渲染的普通组件要高。

常用的几个原生组件有：
1. video 视频
2. map 地图
3. canvas 画布
4. picker 弹出式选择器

原生组件的优点：
1. 渲染性能更好。原生组件的渲染依靠渲染性能更好的客户端，而不依靠 WebView，减轻了 WebView 线程压力。
2. 数据通信的时延更低。setData 传递数据时，逻辑层发送数据，客户端转发，webView 接受后再传入组件，中间有天生的时延。而原生组件在逻辑层通过 context 修改数据，数据从逻辑层传递到客户端后直接传入组件，显著降低传输时延。

原生组件的缺点：
1. 一些 CSS 样式无法应用于原生组件。比如，不能使用 transform rotate 让原生组件产生旋转。
2. **原生组件浮于其他组件之上，相当于拥有无穷的的 z-index。解决这个问题可以考虑使用 over-view 和 cover-image 原生组件。**


## 六、代码编译
在微信开发者工具，小程序代码经过 “本地预处理 → 本地编译” 过程，而微信客户端的小程序代码还额外经过服务端编译过程。 

以下说的编译都是微信开发者工具对小程序代码的 “本地编译” 过程。

### 6.1 编译 wxml
小程序的 webView 线程无法识别 wxml，所以 wxml 需要经过编译。

编译→ 渲染的过程，如下：
1. 编译。将 wxml 编译解析成一个渲染函数 generateFun，渲染函数用以生成虚拟 DOM（描述页面结构的 json）
2. 渲染。创建页面时，给渲染函数传入页面数据作为参数，生成该页面的 vnode，然后通过 diff 算法进行对比，将对比结果 petch 更新到页面。

> 和 Vue 的虚拟 DOM 设计比较类似 

### 6.2 编译 wxcss
wxss 对 css 进行托充和修改，比如 rpx 尺寸单位和样式导入语法，这些都是 webView 无法直接理解的。

对 wxss 编译时，会分析文件引用关系，预处理 rpx，输出一个样式信息数组。

### 6.3 编译 js
小程序的 js 引擎是可以直接识别 js 代码，所以 js 的编译主要是对 js 代码做一些预处理：
1. 将 ES6 转义成 ES5 （默认转义，除非开发者指定关闭这个转义）
2. 将 js 文件包裹在 define 域，让每一个 js 文件都拥有自己的单独作用域
3. 将 js 文件按照一定顺序合成成一个 app-service.js 文件