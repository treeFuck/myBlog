# 浏览器的多进程与多线程
> 参考博客：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)

## 一、浏览器的多进程
浏览器本身是多进程的的一个应用，负责关键功能的进程有：
1. Browser 进程：浏览器主进程，负责协调，主控，只有一个
2. GPU 进程：最多一个，用于 3D 绘制等
3. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
4. **浏览器渲染进程**：默认每个 tab 页面一个进程，互不影响，负责页面渲染，脚本执行，事件处理等。

对于前端而言，最重要的就是**渲染进程，它也叫浏览器内核、Renderer 进程**，其内部是多线程的。

## 二、浏览器内核的多线程
浏览器内核，即我们的渲染进程，又名 Render 进程，我们页面的渲染、js 的执行、事件的循环都在这个进程里进行，而它内部又拥有多个线程去分工负责这些任务的执行。

这些线程具体如下：
1. **GUI 渲染线程**
	- 负责渲染浏览器页面，包括解析 HTML、CSS、构建 DOM 树、Render 树、布局和绘制等
	- 负责页面的重绘 repaint 和回流 reflow
	- 与 JS 线程互斥
2. **JS 引擎线程**
	- 执行 js 脚本（例如 **V8 引擎**）
	- 处理任务队列里的任务
	- 与 GUI 渲染线程互斥
3. **事件触发线程**
	- 负责 html 元素事件的触发，如鼠标点击某个元素
	- 元素事件触发后，把对应的事件回调放入任务队列，等待 js 线程处理
4. **定时器触发线程**
	- 负责 setInterval 与 setTimeout 定时器的计时工作
	- 计时完毕，触发回调，被事件触发线程添加到任务队列，等待 js 线程处理
5. **异步 http 请求线程**
	- 负责检测 XMLHttpRequest 请求对象的状态
	- XMLHttpRequest 请求完毕，触发回调，被事件触发线程添加到任务队列，等待 js 线程处理

### 2.1  js 线程与 GUI 渲染线程的互斥
它们的互斥的原因很简单。

因为 js 线程可以修改 DOM 结构，如果在 js 线程修改 DOM 结构的同时，GUI 渲染进程也在渲染页面，那么可能导致渲染效果和 DOM 结构不一致。所以，才需要把两个线程设为互斥关系，保证 GUI 渲染的是最新的 DOM 结构。

另外，因为二者是互斥关系，如果 js 线程执行时间过长，会导致 GUI 渲染进程一直不能执行，页面渲染不及时，可能导致首页白屏、页面卡顿等情况。


### 2.2 Web Worker
js 主线程用 web Worker 创建一个新的子线程去执行另一个 js 脚本，这样可以将耗时的、密集的 js 计算工作扔给子线程，降低 js 主线程的工作量，进而让 GUI 渲染线程不至于阻塞，提高页面渲染流畅度。

js 主线程与 web Worker 子线程需要通过特定的方式通信。

