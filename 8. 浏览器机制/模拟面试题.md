# 模拟面试题

## 五、浏览器机制
### 5.1 说一下从输入 url 到页面渲染完毕之间的过程

### 5.2 说一下浏览器内核的多线程

浏览器本身是多进程的一个应用：
1. browser 主进程：负责协调、主控其他进程
2. GPU 进程：负责 3D绘制
3. 插件进程：一类插件对应一个进程，使用插件的时候才会被创建
4. 最重要的渲染进程，也叫浏览器内核，内部是多线程的
	- JS 引擎线程：执行 js 脚本代码，比如 v8 引擎。和 GUI 渲染线程互斥
	- GUI 渲染线程：负责解析 HTML、解析 css、回流、重绘。和 js 线程互斥
	- 事件触发线程：控制事件循环，将回调放到任务队列待执行
	- 定时器触发线程：给定时器计时，计时完毕将回调放到任务队列
	- 异步 http 线程：检测 http 请求状态，在请求完毕后将指定回调放到任务队列 

其中，js 引擎线程和 GUI 渲染线程是互斥，因为 js 可以访问 DOM，而 GUI 渲染又依赖一个稳定的 DOM，如果两个可以并行，那么 DOM 的渲染可能会出现错误。

web worker 可以开启一个 js 引擎线程的子线程，它受控于 js 引擎线程，一般用来分离 js 线程的计算任务，避免 js 引擎线程因为 js 计算任务过大而阻塞了 GUI 渲染线程，导致不能及时渲染而产生页面卡顿。

### 5.3 说一下浏览器的垃圾回收

垃圾回收主要说的是 V8 引擎对堆内存的回收。因为存在一些堆内存里的引用对象，它在栈内存里不存在有一个指针指向它，那么这个对象就成为了无法被引用的对象，失去了意义，成为了“垃圾”需要被回收。

V8 的垃圾回收基于分代式垃圾回收策略。分代是意思是将对象分为新生代和老生代，对应的内存页分为新生代内存和老生代内存。

其中，新生代对象，指的是存活周期比较短的对象，比如一个函数里用局部变量引用的对象。新生代对象的垃圾回收方法采用的 GC 复制算法，将新生代内存一分为二，一个叫 From，一个叫 To:

1. 分配内存时，只分配到 From 里
2. 垃圾回收时，将 From 里还存活的对象复制到 To里，剩下的非存活对象就销毁回收
3. 复制完毕，将就 From 和 To 进行角色调换

而老生代对象，就是存活周期比较长的对象，比如全局变量引用的对象、一些被闭包引用的对象等。它们采取的是标记-清除和标记-整理算法。
标记-清除，分为标记和清除两个阶段：

1. 标记阶段，从根变量开始向下递归遍历对象的引用，将对应的堆内存空间做上标记
2. 遍历堆，将堆内存里没有被标记到的对象进行销毁回收 → 因为这些对象无法被引用到了，所以没有意义，只能被回收

标记-清除有一个缺点，是进行垃圾回收后，可能会产生一片不连续的内存空间，那么当需要使用一片连续大内存时可能会触发又一次的垃圾回收。

为了避免这个问题，提出了标记-整理算法，通过移动堆内存里的存活对象，来或得一片连续的空间。

另外，垃圾回收时，js 的解析执行就会暂停，所以垃圾回收耗时不能过长，为此还提出了延迟回收、增量式标记、增量式整理、并行标记等算法。

最后，有一种被淘汰的垃圾回收算法——引用计数算法。它给每一个堆内存对象记录它的引用次数，一旦引用次数为 0，那么这个对象就可以被回收了。但是有一个致命问题就是循环引用，比如 A 引用了 B，B 引用了 A，就会造成 A 和 B 的引用次数起码为 1，A、B 对应的堆内存永远无法被回收，造成内存泄漏。

说到内存泄漏，闭包也是一种常见的内存泄漏。

### 5.4 浏览器存储

常见的浏览器存储有三种方式：
第一种 Cookie。Cookie 作为 HTTP 协议的拓展，一般是用来保持状态的。不过因为它可以通过 document.cookie 进行读写，所以也可以用来作为浏览器存储。不过 cookie 的存储上限是 4 KB，一般不会使用它来进行浏览器存储。而且 http-only 设为 true 的 cookie 也是不能用 js 进行读取的。

第二种是 LocalStorage 和 sessionStorage，它们的存储上限是 5 M，比 Cookie 更适合浏览器存储，二者区别：

1. LocalStorage 是长期存储，需要手动清除；SeesionStorage 是会话存储，会话介绍后自动清除。
2. LoaclStorage 可以在同源页面下共享；SeesionStorage 只能在同源且同一标签页下共享

LocalStorage 和 sessionStorage 的优点是存储方便，缺点是键值只能是字符串，存储 json 时需要转义。


第三种是 IndexDB，是一个运行在浏览器的非关系型数据库，没有存储上限，一般来说不低于 250 M，键值对存储，键值可以是二进制数据，异步读写。

另外，Cookie、LocalStorage、sessionStorage、IndexDB，都是支持同源策略的。

### 5.5 事件循环

浏览器用事件循环来处理各种异步回调。事件循环是维护了一个任务队列，任务队列里都是一些待执行的任务，当主线程为空时，就会去读取任务队列里的任务。

任务队列里任务分两类：

1. 宏任务，比如定时器回调、http 回调、DOM 事件回调等
2. 微任务，比如 Promise 的 then 回调

在一轮的事件循环里，执行顺序是：

1. 先执行一个宏任务
2. 再执行全部微任务
3. 判断是否需要重新渲染，需要则重新进行页面渲染

我们在 js 代码里往往会发现，第一个微任务执行得比第一个宏任务要早，但其实不是。因为 script 脚本的加载执行本身也是一个宏任务，本质还是先执行一个宏任务再执行全部微任务。

NodeJS 的事件循环和浏览器的事件循环类似，但也有不同，不同点在于：

1. 宏任务队列分为 6 中，对应事件循环 6 个阶段，而且一次事件循环会执行掉全部的宏任务
2. 微任务的执行时机是一个宏任务队列里的宏任务全部执行完毕后。不过有一个阶段特殊，就是 poll 阶段，它是没执行一个宏任务后就清空一次微任务队列