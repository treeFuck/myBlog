# 浏览器缓存

## 一、概述
当请求一个资源时，会先去查找浏览器缓存，查找不到时才会去请求网络。根据缓存位置上不同，浏览器缓存可以分为以下四类：
1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache（HTTP/2.0 内容，略过）

## 二、缓存分类
### 2.1 Service Worker
允许在浏览器背后的独立线程，类似 web worker，可由开发者高度自定义，可以用来实现缓存功能：
1. 必须使用 HTTPS，因为涉及到请求的拦截，必须保证请求的安全
2. 让开发者自由控制缓存哪些文件、如何匹配缓存、如果读取缓存……
3. 优先级比其他内存缓存和磁盘缓存要高
4. 当 Service Worker 没有命中缓存，会按照 内存缓存 →  磁盘缓存 → fecth 网络请求 的顺序去获取资源，并返回给浏览器，所以浏览器只会显示该资源是从 Service Worker 中获取的

### 2.2 Memory Cache
存储在计算机内存中的缓存：
1. 快，读取计算机内存肯定比读取磁盘块
2. 小，计算机内存容量一定比磁盘小
3. 周期短，tab 页面一关闭，内存中的缓存就被释放了

### 2.3 Disk Cache
存储在磁盘上的缓存：
1. 慢，读取速度被内存缓存慢
2. 大，磁盘空间比较大
3. 周期长，存储周期比较长

## 三、缓存过程
浏览器的对 http 请求资源的缓存：
1. 发起请求前，会去缓存看看，有没有所请求资源的缓存
	+ 没有，则向服务器发送资源请求
	+ 有，且没过期，则直接将缓存资源返回**（强缓存）**
	+ 有，但已过期，则用缓存的缓存标识向服务器发起请求，判断改资源是否有过更新**（协商缓存）**
		- 该资源没更新，服务器返回 304，继续使用缓存的资源
		- 该资源已更新，服务器返回更新后的资源，状态码为 200
2. 拿到请求响应的资源后，会分析响应首部里一些有关缓存的字段，比如 Expires、Cache-Control，来进行资源的缓存。

所以缓存过程可以分为两个阶段：
1. 缓存没过期，则使用强缓存
2. 缓存已过期，则使用协商缓存

## 四、强缓存
强缓存，就是说缓存还没过期时，不向服务器发送请求，而是直接从缓存中读取资源。使用强缓存的关键在于缓存没有过期，而缓存是否过期，和请求资源时响应报文的两个字段有关：Expires 和 Cache-Control。

### 4.1 Expires 
`Expires`字段，用来指定资源缓存过期的时间，http/1.0 的产物，受限于本地时间，如果修改了本地时间，可能造成缓存失效。

### 4.2 Cache-Control
`Cache-Control`是 http/1.1 的产物，它的字段值可以组合使用多个指令，用以控制网页缓存：

- public：表示客户端和代理服务器都可以缓存这个资源
- private：表示只有客户端能缓存这个资源
- max-age=n：表示缓存 n 秒后，该资源后就过期，需要重新请求
- **no-store：不缓存任何响应**
- **no-cache：资源被缓存，但是立即过期，下次请求该缓存时需要向服务器发起验证**

### 4.3 对比
- Cache-Control 优先级高于 Expires
- Cache-Control 的功能指令更加丰富

## 五、协商缓存
协商缓存，就是本地缓存已经过期了，所以再请求该缓存时，需要用缓存标识向服务器发起一个验证请求，来判断服务端的资源是否更新过，以此来判断是否可以继续使用该缓存：
- 响应返回 304，表示服务端资源没有更新过，缓存还可以继续使用
- 响应返回 200 和请求结果，表示服务端资源已经更新过，缓存不能再继续使用

协商缓存，有两种机制去实现：Last-Modified 和 ETag

### 5.1 Last-Modified 
- Last-Modified：第一次请求资源时，服务端在响应报文放入该字段，表示该资源在服务器最后的修改时间
- If-Modified-Since：发送协商缓存请求时，会在请求报文首部的 If-Modified-Since 字段放入 Last-Modified 的值，让服务端去对比资源的最好更新时间，判断该缓存是否还能继续使用
	+ 资源没有变化，返回 304
	+ 资源变化了，返回 200 和新的资源

### 5.2 ETag
服务端资源可以生成一个唯一标识 ETag，一旦资源发生修改，这个 ETag 也会重新生成。

浏览器在发生协商缓存时，将缓存的 ETag 放到请求头的 If-None-Match 字段里，服务端从里面拿到 缓存的 ETag 和对应服务器资源的 ETag 进行对比，以此来判断缓存资源是否过期：
+ ETag 一致，资源没过期，返回 304
+ ETag 不一致，资源过期，返回 200 和新的资源

### 5.3 对比
- ETag 优先级比 Last-Modified 高
- ETag 的精度比 Last-Modified 高，因为 ETag 可以反映资源的每一次修改，而 Last-Modified 只能反映资源跨秒的修改
- ETag 的性能比 Last-Modified 低，因为 ETag 需要计算出来


## 六、实际应用场景

### 6.1 对于频繁变化的资源 → 协商缓存
> Cache-Control: no-cache

将响应资源设为 `Cache-Control: no-cache`，然后浏览器缓存资源，但是立即将资源置为过期，所以每次请求缓存时候都需要配合 ETag 或者 Last-Modified 来向服务器发起验证请求来判断资源是否过期。

### 6.2 不常变化的资源 → 强缓存
> Cache-Control: max-age=n

对于这类资源，可以通过 `Cache-Control: max-age=n` 将缓存过期时间设为 n 秒后，触发强缓存。对于这类缓存资源，想要更新本地缓存的话，可以借助修改 url 后的 hash 值来使资源的原先强缓存失效。

## 七、用户行为与缓存的关系

1. 第一次打开网页，会使用到 disk cache 硬盘缓存
2. 页面的普通刷新，内存缓存还没有失效，所以会优先使用内存缓存，再使用磁盘缓存
3. 页面的强制刷新，不使用缓存，发送的请求头部全部带有 `Cache-control: no-cache`
