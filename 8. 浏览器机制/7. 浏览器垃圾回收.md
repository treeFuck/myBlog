# 浏览器垃圾回收

## 一、浏览器内存分配
浏览器的内存分两类：栈内存和堆内存。
- 栈内存 → 存放原始值、引用值的地址
- 堆内存 → 存放引用值

两个内存最大是区别是：
- 栈内存里每一个栈的存储是有大小上限的，所以适合原始值的存储；
- 而堆内存里每一个引用值的存储大小是不固定，所以需要用堆来进行动态调整。

拓展问题：垃圾回收机制其实是针对堆内存的，那么为什么栈内存不需要垃圾回收呢？
> 个人猜想，**栈内存**，就按后入先出顺序进行空间分配、回收。比如执行一个函数，函数里定义的变量会入栈，函数执行完毕就出栈，所以应该是**靠栈本身进行空间回收。**
> 
> 换句话说，**栈内存**里面存储的变量，从当前来看**都是“有用的”，而不是“垃圾”**。
> 
> 而引用值会在堆内存里存储，引用值的指针是放在栈内存的，一旦栈内存的指针被栈弹出，该指针在堆内存里的**引用值就变成“没用的”了，成为了“垃圾”，需要进行回收**。


## 二、V8 垃圾回收机制
> 垃圾回收 GC，全拼 Garbage Collection。

堆内存的垃圾回收有很多的算法，而不同的浏览器也可能有不同的实现方案。我们主要看看谷歌浏览器的 V8 引擎的堆内存垃圾回收机制。

V8 的垃圾回收策略是基于分代式垃圾回收机制。什么叫分代呢，就是**将堆内存分两类：新生代和老生代**。顾名思义：
- 新生代对象就是存活时间较短的对象（比如在函数里定义的对象）
- 老生代对象就是存活时间较长的对象（比如在全局定义的对象）

针对两类对象，会有不同内存空间和不同的垃圾回收算法：
- 新生代对象 → 新生代内存空间较小，回收使用 GC 复制算法（Scavenge 算法）
- 老生代对象 → 老生代内存空间较大，回收使用 Mark-Sweep & Mark-Compact（标记清除 & 标记整理）

> GC只复制存活对象，Mark-Sweep 只清除死亡对象。
>
> 存活对象在新生代里占少数，死亡对象在旧生代理占少数。
>
> 这就是两种回收方法性能高效的原因。

### 2.1. 新生代对象垃圾回收算法——Scavenge（GC 复制算法）

将内存空间一分为二，一个叫 From，另一个叫 To，垃圾回收流程如下：
1. 内存分配时，分配到 From
2. 内存回收时，将 From 里的依旧存活的对象放到 To，From 剩下的就是非存活对象，可以进行释放回收
3. 最后，将 From 和 To 进行角色对换。

优点：因为只关注对象是否存活，比较**适合存活周期短的对象，也就是新生代对象的垃圾回收**。
缺点：典型的空间换时间，只能使用被分配的堆内存空间的一半。

### 2.2. 老生代对象垃圾回收算法——Mark-Sweep & Mark-Compact（标记清除 & 标记整理）
Mark-Sweep 标记清除，分标记和清除两个阶段：
1. 标记：从根列表开始深度遍历，标记依旧可以引用到的对象 
2. 清除：遍历堆内存，清除没有标记的对象

> **根列表**，通常是代码中全局变量的引用，而全局变量也是 window 的属性。所以标记清除，可以简单理解为从 window 开始向下深度遍历属性，不可到达的堆内存引用对象即可被回收。

缺点：
1. 标记清除回收之后，得到的内存空间可能是不连续的
2. 标记清除需要两轮遍历，比较耗时，造成 js 线程的阻塞 


针对问题1，提出了 Mark-Compact 标记整理 → 即在 Mark-Sweep 标记清除后，将还存活的对象往一端移动，以获得连续的内存空间。

针对问题2，还提出了增量式标记、增量式整理等，将标记清除和标记整理阶段进行拆分，让垃圾回收和应用逻辑交替执行。

### 2.4 晋升
但一个新生代对象经过多次复制后还存活，它就会被认为是长期存活的对象，而被移入到老生代内存空间里，“晋升”为老生代对象，这就是晋升。

> 猜想：比如正常函数里的变量对象，一般是新生代对象，但如果这个函数是闭包，那么这个对象在函数执行完后不会被立即销毁，下一次进行垃圾回收的时候可能就将它 “晋升“ 为了老生代对象。

晋升的条件一般有两个，两个条件满足一个即可晋升：
1. 该新生代对象是已经历过 Scavenge 回收
2. To 空间的内存占用比超过限制，这个限制一般是新生代内存空间的 25%

### 2.5 V8 的内存限制

**V8 的内存限制和垃圾回收本身的耗时有关。**

我们知道，**V8 进行垃圾回收时，js 线程会被暂停**，那么如果垃圾回收的时间很久而导致 js 线程的过久阻塞，造成的用户体验就很差，所以，需要降低 V8 垃圾回收的耗时。

前面提过的增量式标记、增量式整理、还有延迟清理、并行标记、并行清理等都是提高 V8 垃圾回收速度的方法。不过，要从根本上限制 V8 垃圾回收的耗时，还是得从内存限制上入手。

刚刚说过，老生代内存空间进行标记-清除垃圾回收时，需要遍历堆里的对象引用，而这个遍历比较耗时。并且这个**耗时跟堆的大小是直接挂钩**的，所以直接限制 V8 可使用的内存空间是最直接的办法。

而且，一般前端 web 页面里 js 不会使用到太多的内存，所以这个限制没有太大的问题。不过我们知道 **Node 也是使用 V8 引擎去解析执行 js 代码的，这个限制导致了 Node 搭建的服务在内存使用上存在限制**，这一点需要注意。

### 2.6 被淘汰的垃圾回收算法——引用计数
引用计数，顾名思义，给每一个堆内存对象记录它被引用的次数，有新的引用指针指向它了引用计数就+1，移除了它原本的引用指针就把引用计数-1，最后的引用计数为 0 时，就回收该对象堆内存。

但是这个**引用计数有一个致命的缺点，就是循环引用**。所谓循环引用，就是 A 对象引用了 B，而 B 对象引用了 A，那么这两个对象的引用次数永远至少为 1（哪怕已经没有其他指针可以引用到这两个对象了），也就永远无法进行垃圾回收，这段内存无法回收也就造成了内存泄漏。

### 2.7  内存泄漏
**一块内存因为某种原因而导致一直无法回收，就叫内存泄漏。**

#### 2.7.1 意外的全局变量
```js
let fun = ()=>{
	a = {};
	this.b = {};
}
```
上例中，a 和 b 变量都是定义在全局上的，无法随函数执行完毕后进行垃圾回收，所以造成了内存泄漏。
#### 2.7.2 闭包
```js
let fun1 = ()=>{
	lat a = {};
	return ()=>{}
}
let fun2 = fun1();
```
在上例中，因为 fun2 作为闭包始终引用着 a，但是 a 实际上并没有被 fun2 使用到，所以 a 所指向的引用对象没有意义，但其所在的堆内存就也无法被回收，造成内存泄漏。

为了避免这种情况，闭包应该只引用需要引用的变量：
```js
let fun1 = ()=>{
	lat a = {};
	let b = 99;
	a = null; // 闭包不使用的变量，则解除引用让其可以回收
	return ()=>console.log(b);
}
let fun2 = fun1();
```
#### 2.7.3 脱离 DOM 的引用
```js
let elements = {
	button: document.getElementById('button')
}
...
document.body.removeChild(document.getElementById('button'));
```
在上例中，通过 elements 引用了 button 元素，然后在后续的逻辑里把该元素从 DOM 里移除了，按照逻辑从 DOM 里被移除的元素应该要被回收，但因为 elements 还引用着 button，所以 button 元素无法被回收，除非将 elements.button 置空。

或者可以使用 WeakMap 和 WeakSet 来引用 DOM 元素，它们对对象都是若引用，不会干扰对象引用的堆内存回收。



> 参考文献：
>
> 《深入浅出 Node.js》—— 朴灵
>
> [JavaScript深入之4类常见内存泄漏及如何避免](https://github.com/yygmind/blog/issues/16)——木易杨
>
> [JavaScript 内存泄漏教程](https://www.ruanyifeng.com/blog/2017/04/memory-leak.html)——阮一峰