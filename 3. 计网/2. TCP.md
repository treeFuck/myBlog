# TCP 

## 一、传输层
### 1.1 基本概念
1. 从运输层的角度看，**通信的真正端点**是两个主机中的**进程**。
2. 网络层只对 IP 数据报的首部进行检验，而运输层还要对报文进行差错检测。
3. 运输层的两个主要协议：TCP 和 UDP
4. 对于应用层而言，只能看见运输层为其提供一条端对端的逻辑通信信道。但运输层协议不同，这条通信信道对上层的表现也不同：
	- **面向连接的 TCP 协议 → 一条全双工的可靠信道**
	- **无连接的 UDP 协议 → 一条不可靠信道**
### 1.2 运输层的两个主要协议：TCP 和 UDP
**用户数据报协议 UDP：**

1. 传输单位 → UDP 用户数据报
2. **无连接**
3. **尽最大努力交付** → 不保证可靠交付
4. **支持一对一、一对多、多对一和多对多的交互通信**
5. 首部开销小，只有 8 个字节，而 TCP 首部至少有 20 个字节

**传输控制协议 TCP ：**

1. 传输单位 → TCP 报文段 
2. **面向连接** → 在数据传输前必须建立连接，数据传输结束后要释放连接 
3. **提供可靠交付的服务** → 通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达
4. **只支持点对点全双工通信** → 每条 TCP 连接只能有两个端点
5. 首部开销大，至少有 20 个字节（首部不使用“选项”字段）
6. **面向字节流** → 将应用进程交予的数据仅仅看成一连串的无结构的字节流

### 1.3 运输层的复用和分用
复用：应用层所有的应用进程都可以通过运输层再传送到网络层
分用：运输层从网络层收到数据后必须交付给指明的应用进程

> 运输层的分用主要靠**运输层的协议端口**来实现

## 二、TCP 协议

### 2.1 TCP 的连接
TCP连接的端点是什么呢？不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口，**TCP连接的端点叫做套接字 (socket) 或插口**。

**套接字组成 = (IP地址: 端口号)**

**所以，TCP 连接 = {socket1, socket2} = { (IP1: port1), (IP2: port2) }**

> 所以，两台计算机中的进程要互相通信，不仅要知道对方的IP地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）

### 2.2 首部
![](./TCP首部.jfif)

1. 源端口和目的端口：用以实现 TCP 分用功能
2. 序号：在一个 TCP 连接中传送的字节流的每一个字节都是按顺序编号的
3. 确认号：期待对方下一个报文的第一个数据字节的序号
4. 数据偏移：首部长度
5. 保留位：保留为将来所用
6. URG：为 1 时，紧急指针字段有效
7. ACK：建立连接后，所有传送的报文段都必须把 ACK 置 1
8. PSH：接受方收到 TCP 报文 PSH 为 1，就尽快响应
9. RST：为 1 时，表明 TCP 连接中出现严重错误
10. SYN：建立连接时，发送报文 SYN = 1，ACK = 0；对方同意建立连接，响应报文 SYN = 1，ACK = 1
11. FIN：发送报文 FIN = 1 表示发送方想释放连接
12. 窗口：窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。
13. 校验和：用以校验首部和数据
14. 紧急指针：在 URG 为 1 时有效，值出本报文段中紧急数据的字节数
15. 选项：长度可变，最长可达 40 字节。如果一个报文首部不使用选项，那么首部长度为 20 字节。


### 2.3 可靠传输
**网络层只提供尽最大努力服务，所以运输层的 TCP 必须采用适当的措施才能使得通信变得可靠。**

具体一点，就是使用一些可靠传输协议，当出现差错时让发现方重发出错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。

常见传输协议协议有：停止等待协议、连续ARQ协议、滑动窗口协议。其中 **TCP 使用的是滑动窗口协议来实现可靠传输**。

### 2.4 流量控制
所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及处理。

**TCP 主要利用滑动窗口协议机制来实现流量控制**。

### 2.5 拥塞控制
所谓拥塞，是指对网络中某一资源的需求超过了该资源所能提供的部分。而所谓拥塞控制，就是防止过多的数据注入到网络中。

拥塞控制是一个全局性的过程，涉及到网络里所有与降低传输性能有关的因素。而相反，流量控制指的是点对点通信量的控制，是一个端到端的问题。

RFC 标准定义了进行拥塞控制的四种算法：**慢开始、拥塞避免、快重传、快恢复。**

### 2.6 运输连接管理
运输连接有三个阶段：
1. 连接建立 → 三次握手
2. 数据传送 
3. 连接释放 → 四次挥手

主动发起连接建立的应用进程叫做客户(client)，而被动等待连接建立的应用进程叫做服务器(server)。

## 三、TCP 三次握手建立连接
![](./三次握手.jfif)

### 3.1 **为什么要进行第三次握手？**

主要为了防止**已经失效的连接请求到达服务端**而产生错误。

假设一个已经失效的连接请求到达服务端，服务端以为客户端又发起连接请求，会返回一个确认。但因为这是一个失效请求的确认，所以客户端会无视它，也不会进行第三次握手给服务端返回一个确认。

服务端没有第三次握手收不到确认，就会明白刚刚那是一个失效的连接请求，客户端现在并没有要建立连接的意思。

> 相反，如果没有第三次握手，那么第二次握手的时候，服务端就以为建立了连接。哪怕是那么对于客户端失效的连接请求，服务端也依旧以为要建立连接。那么就会出现 ”**客户端没有建立连接的意思，而服务端以为建立了连接**“ 的尴尬局面。

## 四、TCP 四次挥手释放连接
![](./四次挥手.jfif)

### 4.1 第二次挥手和第三次挥手的区别？两者能不能合并？
不能合并。

**第二次挥手是对客户端发起释放报文段的确认回应。**这个时候，服务端可能还有数据要发给客户端，换句话说，**服务端可能还没有准备好释放连接**。

**第三次挥手，就是服务端已经准备好释放连接了**，所以给客户端发送一个 FIN = 1 的报文段告诉客户端它这边准备好释放连接了。 

### 4.2 为什么客户端在 TIME-WAIT (时间等待) 状态必须等待 2MSL 的时间？
**第一，保证第四次握手时，客户端发送的报文能到被服务端收到。**因为这个报文可能会丢失、延迟等导致服务端重新发起第三次握手，进而客户端又发起新的第四次握手，并重启 2MSL 计时器。

**第二，处理三次握手里 ”已失效的连接请求到达服务端“ 这种情况**，使本次 TCP 连接里所产生的所有报文段都从网络中消失，避免它进入下一次的 TCP 连接。

## 五、TCP的有限状态机
![](./TCP的有限状态机.jfif)