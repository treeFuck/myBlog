# webpack

## 一、webpack 是什么
webpack 本质是一个 node 程序，用以打包构建前端项目。webpack-cli 是脚手架工具，用以方便开发者用 webpack 构建一个项目。

**个人认为 webpack 的意义在于两点：**

1. **基本的构建功能。webpack 作为构建工具，可以处理复杂的模块依赖关系，输入可以直接简单引用的构建结果。**
2. **webpack 的拓展功能。webpack 将整个构建过程暴露出来，让开发者通过 loader 和 plugin 可以参与到构建的过程来执行自定义的拓展功能，比如对 ES6 语法进行转义、压缩图片、压缩 js、去除 log 等。这也是 webpack 生态丰富的根本原因。**

基本概念：
1. entry：webpack 打包入口
2. module：模块，对于 webpack 而言，一切皆模块，包括 html、js、css、图片、字体……
3. chunk：代码块，webpack 会从 entry 开始检索，将具有依赖关系的模块生成一颗依赖树，最终得到一个 chunk。
4. bundle：chunk 的打包产物。
5. loader：本质是一个函数，用来对一些静态资源进行转义。
6. plugin：插件，用来拓展 webpack 的功能，会在特定时机执行特定的功能。
7. mode：模式，取值为 development，production，none

## 二、webpack 构建过程
1. **初始化参数：合并命令行和 webpack.config.js 的配置参数，得到配置项。**
2. **准备编译：用配置参数去创建 compiler 对象，执行 compiler 对象的 run 方法。**
3. **编译：从 entry 入口开始解析文件，用 loader 对文件进行转译，找到依赖，递归解析下去。**
4. **编译完毕：得到模块依赖树，生成 chunk 代码块。**
5. **输出资源：对 chunk 进行打包，并将打包结果输出到文件系统**

在 webpack 构建过程中，会暴露出一些事件钩子，插件通过注册这些钩子回调，可以参与到构建过程当中来执行一些拓展的功能，比如压缩 js 代码。

## 三、loader

### 3.1 什么是 loader
**每一个 loader 本质是一个函数**，用以对静态资源进行**转义**。另外，loader 还可以进行**链式调用**。

为什么要转义，因为 webpack 只能理解 JavaScript 和 JSON 文件，而通过 loader 转义，各种静态资源都可以转化为 webpack 可识别的模块，进而可以被添加到依赖树中进行打包。

loader 输入：文件字符串、上一个 loader 转化的结果
loader 输出：文件字符串、source map、AST 对象

### 3.2 常见 loader
1. babel-loader：将 ES6+ 编译为 ES5，解决 ES6 的兼容问题
2. ts-loader：编译 typescript
3. sass-loader：将 sass 转化为 css 语法，然后被 css-loader 处理
4. css-loader：将 css 压缩为 js 字符串，并存放到一个数组里面去，让 style-loader 去处理
5. style-loader：将 css-loader 的处理结果转化为一段 js 代码，这段代码可以将 css 注入到 html
6. image-loader：压缩图片
7. file-loader：处理文件类型的资源，返回它的引用地址
8. url-loader：和 file-loader 类似，不同的是它可以设定一个文件大小的阈值，大于该阈值与 file-loader 一样返回引用地址，小于阈值时返回文件的 base64 编码
9. vue-loader：处理 .vue 组件，将组件的 template、js、样式进行拆分
10. vue-template-compiler：对 template 进行模板编译。vue 运行时版本会在 webpack 构建时使用该 loader 进行模板编译，压缩代码体积（去掉编译器代码），加快运行速度（不用编译）。

### 3.3 如何编写一个 loader

编写 loader，要遵循单一原则，每个 loader 只做一种转义工作。loader 本质是一个函数，对输入参数的内容进行转义处理然后返回出来。返回的方式有三种：
1. 直接 return，一般是 loader 只有一个处理结果
2. this.callback，一般是 loader 有多个处理结果
3. 用 this.async 来创建 callback，可以用来创建异步 loader

## 四、plugin

### 4.1 什么是 plugin
插件的意义在于拓展 webpack 功能。webpack 在构建时候会暴露出很多事件钩子，插件通过给这些钩子注册回调来参与到 webpack 的构建过程，进行去执行一些自定义的拓展功能。

### 4.2 常见 plugin
- uglifyjs-webpack-plugin：压缩 js 代码，可以配合 tree-sharking。
- split-chunks-plugin：代码分片。webpack 4 之前使用的是 commons-chunk-plugin。

### 4.3 如何编写一个 plugin
1. 定义一个**插件函数**，在它的**原型**上定义一个 **apply** 方法。webpack 会执行插件原型上的 apply 方法来**注册该插件**
2. 在 apply 方法里，通过**指定 webapak 的事件钩子**来注入插件的方法。当 webpack 构建到指定的钩子时，就可以执行插件注入的方法来实现特定的功能。

```js
// 定义一个插件
function MyPlugin() {};

// 在插件原型上定义 `apply` 方法，安装插件时会执行该方法。
MyPlugin.prototype.apply = function(compiler) {
  // 注册一个 compiler 的事件钩子 done
  compiler.plugin('done', function(compilation, callback) {
      ...
      // 1. 执行插件的核心代码
      // 2. 有一些插件可能是异步的，通过 callback 可以控制异步结束后的操作
      
      // 注册一个 compilation 的事件钩子 optimize
      compilation.plugin('optimize', function(){
      	...
      })
  });
};
```
## 五、Code Splitting 代码分片

### 5.1 概述

**为什么要使用代码分片？**因为 webpack 打包是对多个模块进行整合输出，所以最后的构建结果可能是一个很大的 js 文件，而 js 文件在加载解析时候，会阻塞 GUI 渲染线程的渲染，造成首页白屏，降低页面性能。

具体原理主要是**使用 split-chunks-plugin 插件将公共模块提取出来**，作用如下：
1. 提取公共模块，避免重复构建，**减小整体资源体积**。
2. 公共模块一般是很少被修改的，可以很好地利用**客户端缓存**。
3. 多个构建结果，可以更好利用**浏览器并行下载**的能力。
4. **结合异步加载**的方式，可以实现资源的**按需加载**，而不用一次性加载全部资源。

### 5.2 代码分片的插件
1. commons-chunk-plugin：webpack 4 之前的代码分片插件，因为配置麻烦、破坏原有依赖等原因而被淘汰
2. split-chunks-plugin：比起前者功能更强大，且更简单易用。前者的使用是类似命令式的方式，配置复杂，提取多个 vendor 则需要配置多个插件；后置的使用更像声明式，配置简单，满足特定配置条件的 vendor 会被自动提取出来。

### 5.3 资源异步加载
webpack 提供一个 import 函数，支持动态加载模块，另外它也被列入了 ES2020 提案当中。

注意**区分 import 语句与 import 函数：**
1. **import 语句：`import * from 'a.js'`，编译时加载，只能写在顶层作用域**
2. **import 函数：`import('a.js')`，运行时加载，异步加载返回一个 promise 对象，能写在任意作用域**
3. **require 方法：`require('a.js')`，运行时加载，同步加载，能写在任意作用域**

`import()`可以赋予应用很强的动态特性，它经常被用来在用户切换到某些特定路由时去渲染相应组件，这样分离之后首屏加载的资源就会小很多。

比如，vue-router 里可以将一个路由的 component  指定为 `()=>import('test.vue')`，进行合理代码分片可以让 test.vue 资源在切换到该路由时才请求加载。

## 六、tree-shaking
tree-shaking 可以**检测项目里面没有被引用过的模块**（这部分代码也叫“**死代码**”），然后在打包构建的时候移除它。

另外要知道，**tree-shaking 本身只是给死代码添加上标记，真正去除死代码是通过压缩工具比如 uglifyjs-webpack-plugin (压缩 js 代码) 来进行的。**

**实现 tree shaking 需要一些前提条件：**

1. **只对 ES6 Module 有效。**因为 ES6 Module 之间的依赖关系是静态的，在编译的时候就可以识别出来。CommonJs 的模块依赖关系是动态，代码运行时才能检测出来。
2. **如果在工程里使用了 babel-loader，那么需要禁用 babel-loader 对模块依赖的转义，避免将 ES6 Module 语法转义成 CommonJs。**


## 七、HMR 热更新
全称，**模块热替换功能**（Hot Module Replacement，**HMR**），一种可以**将代码的修改实时更新到页面**的机制。

大致原理如下：
1. **webpack-dev-server (WDS) 通过 express 搭建了一个本地服务，和浏览器建立 websocket 连接。一旦本地资源有修改，WDS 向浏览器推送更新事件，并附带本次资源构建的 hash。**
2. **浏览器通过 hash 来判断是否拉取新的资源。如果需要拉取，则向 WDS 发起资源拉取请求。一般是先请求文件更新列表，再借助列表来请求具体的更新增量。**

> 客户端怎么开启 websocket ?
> 答：通过注入特殊的入口文件，来让最后的打包结果里有特定注入的代码，注入代码里有开启 websocket 的代码。

## 八、hash、chunkhash、contenthash的区别

hash 值是打包后的一个文件尾缀，当服务端文件的 hash 改变时，会导致客户端的本地缓存失效，重新拉取新的资源。

webpack 构建文件的 hash 值分三类：hash、chunkhash、contenthash

### 8.1 hash

细粒度：项目的全部文件的 hash 都一样。

修改机制：一个文件被修改了，整个项目里全部文件的 hash 值都会被改变。

缺点：对于项目里没有被修改过的文件，hash 值也会改变，不能很好利用客户端缓存。

### 8.2 chunkhash

细粒度：不同 chunk 的文件 hash 值不一样。

修改机制：一个文件被修改了，它对应的 chunk 里的全部文件的 hash 值都会被改变。

优点：将公共模块抽离成单独的 chunk，避免公共模块的 hash 被修改，更好地利用客户端缓存能力。

缺点：对于一个 chunk 而言，里面有一个文件被修改，整个 chunk 的 hash 都会修改。

### 8.3 contenthash

细粒度：不同文件的 hash 值不一样。

修改机制：一个文件被修改了，它的 hash 值会被修改。

优点：针对文件内容级别的 hash 值，能够最大程度利用客户端缓存能力。

缺点：(猜测，因为 hash 的修改细粒度更小，判断过程可能更复杂，构建时的工作量会更大)