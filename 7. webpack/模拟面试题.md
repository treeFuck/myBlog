# 模拟面试题

## 十、webpack
### 7.1 webpack 构建原理

webpack 构建，就是将一个项目工程里复杂的模块依赖关系进行处理，最后输出一个或几个构建结果。另外 webpack 还把整个构建过程暴露出来，让开发者可以通过 loader 或 plugin 去参与构建过程来执行一些自定义的拓展功能。

webpack 的构建过程如下：
首先，解析命令行指定的和配置文件（webpack.config.js）指定的配置性参数，来获取初始的配置项。
然后，正式编译。从 entry 入口开始，用 loader 将文件转义成 webpack 可以识别的模块，并对其依赖的模块进行递归的解析，这样最后就能得到整个模块依赖树，并生成对应的 chunk 代码块，最后对这个 chunk 代码块进行打包构建，将最后的构建结果输入到文件系统。 

### 7.2 常见 loader

loader 本质是一个函数，用来对文件转义成 webpack 可识别的模块，因为 webpack 只能识别 js 和 json 文件。因为 loader 的存在，webpack 才拥有 “一切皆模块” 的思想。

比如有一个 sass 文件，首先会使用 sass-loader 把它转义成一个 css 文件，再用 css-loader 把 css 文件转义成一段 js 字符串，最后用 style-loader 这段字符串转义成一段代码，这段代码就是用来把 css 插入到 html 里面去的。可以看到最后把 sass 文件转义成一段 js 代码，这段 js 代码 webpack 自然能识别并且进行模块依赖分析的。

常见 loader：

1. babel-loader：将 es6 转义成 es5
2. ts-loader：编译 ts
3. vue-loader：处理 .vue 文件，将 template、js、样式进行分离
4. vue-template-complier：对 complier 进行模板编译。

### 7.3 常见 plugin

webpack 会把构建过程暴露出一些事件钩子，插件会注册对应事件钩子的回调，然后在构建过程特定的时刻里执行自定义的代码，对 webpack 功能进行拓展。

常见的插件，有压缩 js 代码的 uglifyjs-webpack-plugin，用来代码分片的 split-chunks-plugin。

### 7.4 代码分片

使用 webpack 打包后，可能得到单独一个很大的 js 文件。我们知道，js 的解析执行会阻塞渲染线程的及时渲染，所以我们下载一个很大的 js 文件可能会导致首页白屏。

所以，就需要代码分片。代码分片本质是将项目里公共的模块提取出来，作为单独的构建输出。这样有什么好处呢：

1. 提取公共模块，避免公共模块的重复构建，减少整体构建资源的大小
2. 公共模块是很少进行 修改的，所以可以很好利用客户端缓存能力
3. 多个构建文件的下载，可以利用浏览器的并行下载能力
4. 结合异步加载的形式，可以实现资源的按需加载，而不是一次加载全部资源导致首页白屏

#### 7.5 tree-shaking

tree-shaking，去除死代码。什么叫死代码，就是在一个项目工程里引入了一个模块，但是没有任何的其他模块去引用它，所以这个模块也就是无用模块，也叫死代码。

tree-shaking 本质就是给死代码添加标记，然后通过压缩工具去移除死代码，以减少最后的构建体积。

tree-shaking 有两个注意点：

1. 模块必须是 ES6 module。因为 ES6 module 是静态加载，在代码编译时就能分析出模块依赖关系，以便查出那些模块属于“死代码”
2. 禁用 babel-loader 对 ES6 module 语法的转义，不然它会把 ES6 module 转义成 CommonJS，导致无法 tree-shaking

### 7.6 HMR 热更新 

热更新就是修改代码后，不需要手动刷新浏览器，页面会自带更新修改后的状态。

原理是：

1. 本地搭建一个服务，和前端页面建立 websocket 连接，一旦本地资源有修改，就向前端页面推送更新事件，并附带更新的 hash 值
2. 前端页面判断这个 hash 值来决定要不要进行更新。如果需要，则向本地服务发起 jsonp 的拉取资源更新请求。

至于前端页面是怎么建立 websocket 连接，是因为 webpack 构建时，混入一个特殊的入口文件，这个入口文件会导致最后的构建结果里有一段特殊的段代码，这段代码就是用来开启 websocket 的。