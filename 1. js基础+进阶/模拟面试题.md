# 模拟面试题

## 六、js + ES6
### 6.1 说一下闭包
什么是闭包？简单来说，就是一个函数，它能够访问另外一个函数作用域。通常的用法，是比如在函数 A 里定义函数 B 并返回，这时执行 A 得到的 B 就是一个闭包。

闭包的作用：
1. 能够访问另外一个函数的作用域；
2. 创建闭包的函数执行完后它变量对象不会被立即回收，所以可以对闭包的作用域链进行特例化。

闭包的缺点：
1. 闭包会导致一些变量不被垃圾回收机制回收，造成内存消耗
2. 过度使用闭包会造成内存泄漏 

### 6.2 为什么闭包会导致一些变量无法被回收
首先我们要知道，一个函数的作用域链创建过程：
1. 函数定义时：将所在作用域的作用域链赋给函数的 [[Scope]] 变量
2. 函数执行时：生成自己的 AO 对象，复制 [[Scope]] 并将 AO 放到最前面，这样就得到自己的作用域链

正常一个函数执行完毕后，它的作用域链和变量对象都要被回收。
但闭包不一样。比如在 A 里定义 B 并返回，B 的 [[Scope]] 会一直引用着 A 的变量对象，导致它不能被正常回收。

### 6.3 什么是内存泄漏
内存泄漏是指，一块内存不被应用程序使用，但是又因为其他原因而无法进行回收利用。内存泄漏可能会导致应用程序卡顿或奔溃。

### 6.4 说一下原型
js 规定，每一个构造函数都有一个原型指针，指向它的原型对象。而构造函数创建处理的实例，也有一个原型指针，指向这个原型对象。

原型有什么用？js 规定，当访问一个对象上的某个属性访问不到时，就会向它的原型上找该属性，如果原型上还找不到，就到原型的原型上找，一直找到原型为 null 为止。

原型上还有原型，就形成了原型链，Object 构造函数的原型是一切原型链的终点，因为 Object 构造函数的原型的原型是 null。

另外，原型链可以用来实现继承。

### 6.5 说一下继承
传统的 js 继承，大致分三类：
借用构造函数继承：在子类构造函数内部通过 call 去执行父类构造函数。
优点：通过给父类构造函数传参，可以给子类特例化属性继承
缺点：每个实例都拥有自己的但功能相同的继承方法，造成内存浪费。

原型链继承：指定一个对象的原型是另一个对象。
优点：可以做到方法继承的复用
缺点：但属性的继承是全部实例共享，无法特例化

组合继承：借用构造函数继承来继承属性，原型链继承来继承方法
优点：结合前面两者的优点

另外，ES6 提出了一种 class 语法糖，它的继承模式和组合继承类似，但也有一定区别

### 6.6 class 继承和组合继承的区别
- 组合继承：先创建子类 this，再通过 call 执行父类构造函数来修改 this
- class 继承：先执行 super 创建父类 this，再执行子类构造函数来修改 this

### 6.7 class 和传统构造函数的区别
- class 定义是原型方法都是不可枚举的，传统构造函数的原型方法是可枚举的
- class 必须要 new 操作符来执行，构造函数可以不用 new（比如用 call 指定 this）
- class 不会变量提升，构造函数 function 可以变量提升
- class 不支持私有属性、私有方法，构造函数支持定义私有属性、私有方法
- 继承机制不一样：class 是先创建父类 this，在执行子类构造函数来修改 this；构造函数是先创建子类 this，再执行父类构造函数修改 this
- class 允许用 extend 操作符来继承原生的构造函数，比如对象构造函数 Object、Array

### 6.8 说一下作用域和作用域链
一个函数的作用域，就是这个函数所能访问的变量范围。

作用域链的产生，分两步：
1. 函数定义时，会用函数的 [[Scope]] 内部属性去指向，函数定义所在的作用域链。如果是在全局范围，那么这个作用域链就是一个简单的 GO 对象
2. 函数执行时，会用执行的参数、内部变量等创建一个变量对象 AO，并复制 [[Scope]] 内部属性上的作用域链，将 AO 对象放到作用域链最前端，这样就是产生了它自己的作用域链。

### 6.9 说一下 this 
this，可以简单理解为函数的作用域。一个函数 this 的指向，分五类：
1. 默认绑定：非严格模式下，this 默认是 window；严格模式下，this 默认是 undefined
2. 隐式绑定：谁调用这个函数，那么 this 就指向谁。隐式绑定优先级高于默认绑定。
3. 显示绑定：通过 call、bind、apply 指定函数的 this。显示绑定的优先级高于隐式绑定。
4. new 绑定：new 是创建一个空对象然后让函数的 this 指向这个空对象。new 绑定的优先级高于显示绑定
5. 箭头函数的 this：箭头函数的 this，是它外部作用域的 this。对于箭头函数而言，显示绑定和 new 绑定都无效

### 6.10 call 和 apply 哪个更快
call，因为 apply 还需要从数组里把参数给读取出来。
### 6.11 写一个 call / apply / bind
```js
Function.prototype.callFun = function(context, ...args) {
	if (!context) {
		context = window; // context 为空，则绑定作用域为 window
	} else if (context instanceof Object === false) {
		context = new Object(context); // context 为非对象，转化为对象
	}
	context._fun = this;
	let res = context._fun(...agrs);
	delete context._fun;
	return res;
}

Function.prototype.bindFun = function(context, ...args1) {
	if (!context) {
		context = window;
	} else if (typeof context !== 'object') {
		context = new Object(context);
	}
	let thatFun = this;
	let fun = function(...args2) {
		if (this instanceof fun) {
			// 如果正在执行 new fun，则 context 应该为 fun 的 this
			context = this;
		}
		thatFun.apply(context, [...args1, ...args2])
	}
	fun.prototype = thatFun.prototype; // 复制原型，避免 new 出错
	return fun;
}
```


### 6.12 写一个 new
new 构造函数创建实例的流程：
1. 创建一个空对象 A
2. 将 A 的原型 A.\_proto\_ 指向构造函数的原型 Ctor.prototype
3. 将构造函数的 this 绑定为空对象，并执行
4. 如果构造函数执行没有返回值，返回空对象 obj
5. 如果构造函数有返回值 res：
	5.1 返回值 res 是个对象，返回 res
	5.2 返回值 res 不是对象，返回 obj

代码模拟：
```js
let newFun = (Ctor, ...args)=> {
	let obj = Object.create(Ctor.prototype);
	let res = Ctor.apply(obj, args);
	return res instanceof Object ? res : obj;
}
```
### 6.13 DOM 操作方法里有没有 insertAfter ? 没有的话能不能模拟？
没有，可以用 insertBefore 和 appendchild 来模拟
```js
Node.prototype.insertAfter = function(newEl, target) {
	let parent = target.parentNode;
	if (target === parent.lastChild) {
		parent.appendChild(newEL);
	} else {
		parent.insertBefore(newEl, target.nextSibling)
	}
}
```
### 6.14 说一下 Promise 实现原理

### 6.15 说一下 async 原理

### 6.16 说一下 js 里的遍历