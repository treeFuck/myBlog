# function 与箭头函数

### 一、定义一个函数
定义一个函数有四种方法：
```js
function fun1() {};
let fun2 = new Function();
let fun3 = function() {};
let fun4 = ()=>{};

console.log(
	typeof fun1, // function
	typeof fun2, // function
	typeof fun3, // function
	typeof fun4  // function
);
```
第一种有变量提升，不符合"先定义后使用"的规范。
第二种写法复杂，很少使用（Vue 源码生成 render 函数的时候倒是用到了它）。

常用是后面两种，本文也是主要介绍后面两种的异同。

### 二、先了解 function
#### 1.  参数
js 对 function 参数的处理也很宽松，它在函数内部维护了一个 arguments 对象，这是一个类数组对象。（注意，它不是 Array 的实例）

我们通过访问 arguments 对象就可以访问我们调用函数时传入的参数。因为 arguments 是个类数组对象， js 里的数组长度不固定，所以我们传递的参数数量也可以不固定。

这个事实说明了ECMAScript函数的一个重要特点：js 函数的形参只提供便利，但不是必需的。

也正是因为这一点，js 的函数没有重载这个概念。
```js
let fun = function(a, b) {
	console.log(...arguments);
}
fun(1);
fun(1, 2);
fun(1, 2, 3);
```
#### 2. this
我个人觉得 function 最有趣也是最复杂的一点，就是有自己的 this。这个 this 的判断也是很复杂的事情，不过可以总结为一句话：**this 指向调用函数的对象**。

当然，我们可以通过 call、apply、bind、new 等操作符来修改它的 this 指向。

```js
let obj = {
	fun: function() {console.log(this)}
};
obj.fun(); // obj
setTimeout(obj.fun, 0); // window
setTimeout(obj.fun.bind(obj), 0); // obj
```
#### 3. 作为构造函数
ES6 之前，js 没有明确的一个类的概念，所以创建对象靠的都是万能的函数。
```js
let fun = function() {
	this.a = 1;
}
console.log(new fun()); // {a: 1}
```
顺便说说 function 作为构造函数时的原型关系。
假设有一个 function 叫 fun，用它可以 new 一个实例 obj。 

fun 作为构造函数，`fun.prototype` 指向它的实例的原型`obj.__proto__`。
fun 作为一个实例，`fun.__proto__` 指向它的构造函数的原型`Function.prototype`
### 三、再说说箭头函数
#### 1.  参数
箭头函数内部没有 argument 变量。不过你可以用 rest 参数替代。
```js
let fun = (a, ...args) => {
	console.log(a, args);
}
fun(1); // 1 []
fun(1, 2); // 1 [2]
fun(1, 2, 3); // 1 [2, 3] 
```
> **注意：rest 参数之后不能再有其他参数（即只能是最后一个参数），否则就会报错。**

#### 2.  this
箭头函数也没有 this。**应该说它没有自己的 this，所以它在调用 this 变量的时候会从作用域链往上走，找到了就拿来用**。

也因为箭头函数没有自己的 this，所以 call、apply、bind 对它自然无效。
```js
let fun1 = function() {
	let fun2 = ()=>{
		console.log(this); 
	}
	fun2(); // obj
	let fun3 = function() {
		console.log(this); 
	}
	fun3(); // window
}
let obj = {};
fun1.call(obj);
```

#### 3.  不能作为构造函数
构造函数的原理，是新建一个空对象，然后将构造函数的 this 绑定为这个空对象，然后再执行构造函数里面的初始化操作。

而前面我们提过，箭头函数是没有自己的 this 的，所以自然是不能用来当构造函数。所以**箭头函数是没有 prototype 属性的**。
```js
let fun = ()=>{};
console.log(fun.prototype); // undefined
console.log(fun.__proto__); // Function.prototype
```

ES6 提出了一个 class 类的概念，专门用于创建对象，将箭头函数与构造函数进行了功能分离。

### 四、作用域
提到函数，不得不提一下函数的执行期上下文、变量对象、作用域与作用域链。最起码，对于这些 function 与箭头函数还是表现得大体一致的。

首先我们说一下**变量对象**。什么是变量对象，就是函数执行的时候，用函数参数和局部变量形成的一个对象，保存了这个函数自身拥有的变量。函数的变量对象叫AO，全局的变量对象叫GO（web环境下GO就是window）。

OK，接下来我们分析函数，我们从创建和调用两部分来讲：

1. **创建。**定义一个函数的时候，会给函数添加一个**内部属性[[Scope]]**，这个内部属性会保留该函数**父作用域的作用域链**。
```js
let a = 1;
let fun1 = ()=>{
	let a = 2;
	let fun2 = ()=>{
		console.log(a);
	}
	fun2();
}
fun1();
/* 1. 定义 fun1 时，
		fun1.[[Scope]] = window -> null
   2. 执行 fun1 定义 fun2 时，
		fun2.[[scope]] = fun1.AO -> window -> null
*/
```
2. **调用。**调用的具体过程大概如下：
	1. 函数执行期上下文被推入执行栈
	2. 复制 [[scope]] 里的 父作用域链
	3. 创建自己的 AO 对象
	4. **把自己的 AO 放到父作用域链的最前端，作为自己的作用域链**
	5. 执行函数
	6. 函数执行完毕，函数执行期上下文被推出执行栈
```js
let a = 1;
let fun1 = ()=>{
	let a = 2;
	let fun2 = ()=>{
		console.log(a);
	}
	fun2();
}
fun1(); // 2
/* 根据上面的分析，可以得知 fun2 最后的作用域链如下：
fun2.作用域链 = fun2.AO -> fun1.AO -> window -> null
根据链级关系，优先访问到 fun2.AO.a = 2。所以最后打印结果是 2
*/
```
### 五、ES6 的函数新特性
#### 1. 函数参数默认值
ES6 里，我们可以给函数参数指定默认值。
```js
let fun = (a = 99)=>{
	console.log(a);
}
fun(); // 99
fun(1); // 1
```
> 注意：参数默认值是**惰性求值**的。
```js
let x = 99;
let fun1 = (a = x+1) => console.log(a);
let fun2 = (a = 100) => console.log(a);

fun1(); // 100
fun2(); // 100

x++;
fun1(); // 101
fun2(); // 100
```

#### 2. 设置函数参数默认值时的作用域
**一旦设置了参数的默认值**，函数进行**声明初始化**时，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失（作用域的变量对象不一定会消失）。

```js
let x = 1;
let fun = (x, y = ()=>{console.log(++x)}) => {
	var x = 66;
	y(); // 100
	console.log(x); // 66
}
fun(99);
console.log(x); // 1
```
在上例中，函数 y 的作用域链是：`y.AO --> 参数作用域.AO --> window`。函数 fun 的作用域链是：`fun.AO --> window`。

在生成`fun.AO`的时候，`fun.AO.x` 本来指向的是参数 x，但是后面又**新定义了一个 x 变量，覆盖了`fun.AO.x`原本的指向**，所以函数 fun 失去了对参数 x 的引用。所以只剩函数 y 的 `参数作用域.AO.x` 对参数 x 还有引用。

```js
let x = 1;
let fun = (x, y = ()=>{console.log(++x)}) => {
	y(); // 100
	console.log(++x); // 101
	y(); // 102
}
fun(99);
console.log(x); // 1
```
而如果没有对 x 进行新定义，那么 **`参数作用域.AO.x` 和 `fun.AO.x` 引用的就是同一个 x**。

#### 3. 尾调用优化
> 尾调用是**函数式编程**的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步 **(return)** 是调用另一个函数。——《ES6标准入门》

那么什么是尾调用优化呢？

我们知道，函数调用会在内存形成一个“调用记录”，又称**“调用帧”**，保存调用位置和内部变量等信息。

如果在函数A的内部调用函数B，那么在A的调用帧上方还会形成一个B的调用帧。等到B运行结束，将结果返回给A，B的调用帧才会消失。

如果B内部还调用了函数C，那就还有一个C的调用帧，以此类推。所有的调用帧会形成一个**“调用栈”**。

**但是！尾调用由于是函数的最后一步操作(return)，所以不需要保留外层函数的调用帧**，因为调用位置、内部变量等信息都不会再用到了，直接用内层函数的调用帧取代外层函数的调用帧就行。

说了那么多，其实还有一个关键点没说：**ES6的尾调用优化只在严格模式下存在，正常模式下是无效的**（*那！要！您！有！什！么！用！呢！🐕*）。
```js
let f1 = ()=>{
	return g(x) + 1; 
	// g(x) 执行完后还有操作，不算尾调用
}
let f2 = ()=>{
	g(x); 
	// 没有 return，不算尾调用
}
let f3 = (x)=>{
	let one = 1
	let g = (x)=>{
		return one + x;
	}
	return g(x); 
	// g(x) 调用了 f3 的局部变量，不算尾调用
}
```

#### 4. 尾递归
函数调用自身叫递归。如果尾调用自身就称为尾递归。

递归非常消耗内存，因为需要同时保存成百上千个调用帧，很容易“栈溢出”，但是**对于尾递归来说，只存在一个调用帧，所以永远不会发生“栈溢出”。**
```js
// 正常递归计算阶乘
let fun1 = (n)=>{
	if (n === 1) return 1;
	return n + fun1(n-1);
}
console.log(fun1(10000));

// 尾递归阶乘
let fun2 = (n, total)=>{
	'use strict'
	if (n === 1) return total;
	return fun2(n-1, n + total);
};
console.log(fun2(10000, 1));
```
> ps：上面的例子是《ES6标准入门》的，我测试过了，发现 fun1(10000)) 没有栈溢出，但是 fun2(10000, 1) 反而栈溢出了……
>
> 呃，俺目前也不知道为什么，可能这个标准Chrome还没有实现吧。