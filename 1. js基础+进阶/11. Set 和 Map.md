# Set 与 Map
## 一、Set
### 1. 概要
**类似数组，但是成员的值都是唯一的，没有重复**。

Set 判断数组去重的标准介于 Object.is 与 === 之间。

我们来复习一下。
1. **对于`===`：**
	- **NaN === NaN 为 false**
	- **+0 === -0 为 true**
2. **对于 `Object.is`：**
	- **Object.is(NaN, NaN) 为 true**
	- **Object.is(+0,  -0) 为 false**
3. **对于 Set 去重：**
	- **NaN 与 NaN 是相同的**
	- **+0 与 -0 是 相同的**

### 2. 拓展
可以用来**数组去重**：
```js
let arr1 = [+0, -0, NaN, NaN, 1, 1, 2];
let arr2 = [...new Set(arr1)];
let arr3 = Array.from(new Set(arr1));
console.log(arr2); // [0, NaN, 1, 2]
console.log(arr3); // [0, NaN, 1, 2]
```
### 3. 属性与 api
1. size：成员数量
1. add：添加某个值，返回 Set 结构本身
2. delete：删除某个值，返回一个布尔值，表示是否删除成果
3. has：返回一个布尔值，判断参数是否为 Set 的成员
4. clear：清楚所有成员，没有返回值

### 4. 遍历
自带遍历器，也有 keys、values、entries 三个实例方法来生成遍历器对象。当然，还有一个 forEach 老方法可以遍历。值得一提的是，它的遍历顺序就是它成员的插入顺序。

不过它的 keys、values 生成的都是一样的遍历器对象，entires 生成的也是一个只有值的数组的遍历器对象。

```js
let set = new Set([5, 6, 7]);
for (let num of set) {
	console.log(num); // 5 6 7
}
for (let num of set.keys()) {
	console.log(num); // 5 6 7
}
for (let num of set.values()) {
	console.log(num); // 5 6 7
}
for (let num of set.entries()) {
	console.log(num); // [5, 5] [6, 6] [7, 7]
}
```
### 5. WeakSet
与 Set 类似，区别有二：
1. 成员只能是对象
2. WeakSet 的成员都是弱引用，所以垃圾回收机制不会考虑 WeakSet 对对象的引用。

api：add、delete、has，没有 delete

遍历：**因为是弱引用，所以不能遍历**。

## 二、Map
### 1. 概要
类似对象，但是键可以是各种类型的值（对象的键只能是字符串）。相同键名写入不同的值，后者会覆盖前者。

Map 的键实际上是和内存地址绑定的，所以只有对同一个对象的引用，Map 结构才将其视为同一个键。

对于 Map 键相同的判断，除了对象引用以外的值判断，采取和 Set 去重一样的标准：
1. NaN 与 NaN 是相同的
2. +0 与 -0 是 相同的

### 2. 属性与 api
1. size：成员数量
2. has(key)：返回布尔值，判断 map 里是否有这个键
3. get(key)：返回 key 键对应的值，没有该 key 返回 undefined
4. set(key, vl)：设定键值对，会覆盖 map 里 key 键原本键值
5. delete(key)：删除某个键，返回 true。删除失败则返回 false
6. clear()：清空全部成员

### 3. 遍历
自带遍历器，也有 keys、values、entries 三个实例方法来生成遍历器对象。当然，还有一个 forEach 老方法可以遍历。值得一提的是，它的遍历顺序就是它成员的插入顺序。
```js
let set = new Map().set(1, 91).set(2, 92).set(3, 93);
for (let num of set) {
	console.log(num); // [1, 91] [2, 92] [3, 93]
}
for (let num of set.keys()) {
	console.log(num); // 1 2 3
}
for (let num of set.values()) {
	console.log(num); // 91 92 93
}
for (let num of set.entries()) {
	console.log(num); // [1, 91] [2, 92] [3, 93]
}
```

### 4. WeakMap
与 Map 类似，区别有二：

1. 只接受对象作为键名(null 除外)
2. WeakMap 键名对于对象引用是弱引用，所以它所指的对象不计入垃圾回收机制

api：get、set、has、delete，没有 clear

遍历：**因为是弱引用，所以不能遍历**。

用途：主要应用场景是，键对应的对象将来可能消失的场景，**有助于防止内存泄漏**。
比如，注册监听事件的 listener 对象很适合用 WeakMap 来实现。

```js
let btn = document.getElementById('btn');
let fun = ()=>{console.log('aaa')};
btn.addEventListener('click', fun, false);
```
上面是常用的事件监听方式，这种绑定有什么坏处呢，就是一旦 btn 这个节点被移除了，但是原本绑定在它上面的事件处理程序 fun 没有被销毁，它因为还有 fun 指针引用着所以无法被销毁而依旧存在。

这个时候，WeakMap 可以派出用场了。
```js
let weakmap = new WeakMap();
let btn = document.getElementById('btn');

weakmap.set(btn, ()=>{console.log('aaa')});
btn.addEventListener('click', weakmap.get(btn), false);
```
我们通过将元素节点与事件处理程序作为键值对放入到一个 WeakMap 里面，一旦元素节点被移除，浏览器会忽略 WeakMap 对元素节点的引用直接回收元素节点，由元素节点作为键引用的事件处理程序自然也会因为失去引用而被回收。
