```js
let noop = function() {}; // 空函数
let then = Promise.resolve();
let nextTick = (fn) => {  
	then.then(fn); // 将 fn 放到微任务队列里执行
}

// 处理回调函数
let handle = (p, deffer)=> {
	if (p.state == 0) {
		p.deffers.push(deffer);
		return;
	}
	while (p.state == 3) {
		p = p.value;
	}
	let cb = p.state == 1 ? deffer.onFullfilled : deffer.onRejected;
	if (cb == null) {
		// 没有指定回调
		if (p.state == 1) {
			_resolve(deffer.promise, p.value);
		} else {
			_reject(deffer.promise, p.value);
		}
		return;
	} 
	// 有指定回调
	try {
		let ret = cb(p.value);
		_resolve(deffer.promise, ret);
	} catch (err) {
		_reject(deffer.promise, err);
	}
}

// resolve 功能函数
let _resolve = (p, vl) => {
	if (vl instanceof myPromise) {
		p.state = 3;
	} else {
		p.state = 1;
	}
	p.value = vl;
	nextTick(()=>{
		for (let deffer of p.deffers) {
			handle(p, deffer);
		}
		p.deffers = [];
	})
}

// rject 功能函数
let _reject = (p, res) => {
	p.state = 2;
	p.value = res;
	if (p.deffers.length == 0) {
		// p.deffers.length 为 0，说明 p 后面没有 then 了，这个错误直接扔出
		throw res;
	}
	nextTick(()=>{
		for (let deffer of p.deffers) {
			handle(p, deffer);
		}
		p.deffers = [];
	})
}

// 定义 handler 类
class Handler {
	constructor(promise, onFullfilled, onRejected) {
		this.promise = promise;
		this.onFullfilled = onFullfilled;
		this.onRejected = onRejected;
	}
}

// 定义 myPromise 类
class myPromise {
	constructor(fn) {
		this.value = null; // 值
		this.state = 0; // 状态
		this.deffers = []; // 存储回调函数
		let resolve = (vl) => {
			_resolve(this, vl);
		}
		let reject = (res) => {
			_reject(this, res);
		}
		try {
			fn(resolve, reject); // 执行异步函数
		} catch (err) {
			_reject(this, err)
		}
	}
	then(onFullfilled, onRejected) {
		let res = new myPromise(noop);
		handle(this, new Handler(res, onFullfilled, onRejected));
		return res;
	}
	catch(onRejected) {
		return this.then(null, onRejected);
	}
	static resolve(vl) {
		return new myPromise((resolve)=>resolve(vl));
	}
} 

// 测试用例
let a = new myPromise((resolve, reject)=> {
	setTimeout(()=> {
		resolve(99);
	}, 1000)
})
a.then(res=>console.log('回调1'));
a.then(res=>console.log('回调2'));
a.then(res=>console.log('回调3'));
a.then(res=>console.log('回调4'));
a.then(res=>console.log('回调5'));

let b = a.then(res=>res+1)
.then(res=>{
	console.log(res);
	throw Error(1);
})
.catch(err=> myPromise.resolve(myPromise.resolve(myPromise.resolve(err))))
.then(res=>console.log(res))
.then(res=>console.log(a, b));
```

