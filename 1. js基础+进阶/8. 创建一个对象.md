# 创建一个对象
## 一、对象创建模式
#### 1. 工厂模式
```js
function Per1(a) {
	let o = {};
	o.a = a;
	a.fun = function() {return this.a};
	return o;
}
let person1 = Per1(1);
```
简介：用函数来封装创建对象的细节。
缺点：无法借鉴对象识别问题（即知道一个对象的类型）。
#### 2. 构造函数模式
```js
function Per2(a) {
	this.a = a;
	this.fun = function() {return this.a};
}
let preson2 = new Per2(1);
```
简介：必须使用 new 操作符创建实例。
优点：使用自定义的构造函数，意味可以将实例标识为一种特定的类型。
缺点：实例方法不能复用，每个实例都要创造自己的同名方法。
#### 3. 原型模式
```js
function Per3() {}
Per3.prototype.a = 0;
Per3.prototype.fun = function() {return this.a}
let person3 = new Per3();
```
简介：属性和方法都定义在原型上，让全部实例共享
优点：方法可以复用，不需要重新定义
缺点：全部实例共享同一个数据属性，没有自己的属性
#### 4. 组合使用构造函数模式和原型模式
```js
function Per4(a) {
	this.a = a;
}
Per4.prototype.fun = function() {return this.a};
let person4 = new Per4();
```
简介：属性定义在构造函数里，方法定义在原型上
优点：可以拥有自己是属性，又能复用方法
#### 5. 动态原型模式
```js
function Per5(a) {
	this.a = a;
	if (typeof Per5.prototype.fun != 'function') {
		Per5.prototype.fun = function() {return this.a};
	}
}
```
简介：将初始化对象的操作全部封装到构造函数里面
优点：封装性更好
#### 6. 寄生构造函数模式
```js
function Per6(a) {
	let o = {};
	o.a = a;
	a.fun = function() {return this.a};
	return o;
}
let person6 = new Per6(1);
```
简介：和工厂模式很像，不同的是这里还是使用 new 操作符。构造函数的作用仅仅是封装创建对象的代码，返回的对象与构造函数与构造函数原型没有半点关系。
#### 7. 稳妥构造函数模式
```js
function Per7(a) {
	let o = new Object();
	let b = a+1;
	a.fun = function() {return b};
	return o;
}
let preson7 = Per7(1);
```
简介：所谓稳妥，就是没有公共属性，生成实例的方法也不引用 this。它适合在一些安全的环境中使用。

## 二、new 
#### 1. 原理
1. 创建一个新对象 obj
2. `obj._proto_ = 构造函数.prototype`
3. **将obj 绑定为构造函数的 this**
4. 执行构造函数
5. 如果构造函数没有返回值，返回 obj
6. 如果构造函数有返回值
	6.1 构造函数的返回值是一个对象，返回这个对象
	6.2 构造函数的返回值不是一个对象，返回 obj
#### 2. 模拟实现
```js
let newFun = (conFun, ...args)=>{
	let obj = Object.create(conFun.prototype);
	let res = conFun.apply(obj, args);
	return res instanceof Object ? res : obj;
}
```

## 三、ES6 class
本质是一个 语法糖，它的绝大部分功能 ES5 也可以做到，class 的写法只是让“类”的概念清晰化，更像是面对对象编程而已。

#### 与 ES5 构造函数的不同
1. class 里的方法都是不可枚举的；构造函数原型上的方法可以枚举。
2. class 必须用 new 来执行，否则会报错；构造函数不用 new 也可以执行。
3. class 不会变量提升；构造函数 function 会变量提升。 
4. class 不支持定义私有属性、方法；构造函数可以在内部定义私有属性方法。（但是 class 可以通过特殊技巧来模拟私有属性、方法，比如借助 Symbol 的唯一性。目前也有一个提案来给 class 添加私有属性，就是在属性名之前加一个#来表示）
5. 实例属性继承机制的不同：ES5 是先创建子类的实例 this，再通过绑定 this 去执行父类的构造函数；class 是先创建父类实例 this，然后再用子类的构造函数去修改 this。
6. 将类看作一个实例的时候，`子类.__proto__ == 父类`(为了继承父类的静态属性和方法)，但 ES5 `构造函数.__proto__ == Function.prototype`。
7. 在 ES5 之前原生的构造函数是不能继承的（因为原生构造函数会忽略this 的显示绑定，导致子类无法拿到原生构造函数的一些内部属性）；class 允许继承原生构造函数来定义子类。

#### super 关键字
这个关键字比较特殊，既可以当构造函数用，也可当对象使用。
1. 构造函数：在子类的构造函数里，作为**父类的构造函数**被调用
2. 对象：
	2.1：在子类方法里用 super 调用父类方法时，super 指向**父类原型**
	2.2：在子类静态方法里用 super 调用父类静态方法时，super 指向**父类**
	2.3：在子类方法里通过 super 对某个属性赋值，super 指向子类实例本身（super 就是 **this**）
