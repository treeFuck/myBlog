# 微前端

## 一、微前端出现的背景
当前，单页面应用是前端比较主流的一种项目形态。但随着时间推移以及功能应用的丰富，单页面应用变得越来越庞大也越来越难以维护，往往改一处而动全身。也就是所谓的 “巨石应用”。

为了对这样应用进行解耦，提出微前端这样一个前端架构概念。

## 二、微前端是什么
> Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. -- Micro Frontends
>
> 微前端是一种**多个团队**通过**独立发布功能**的方式来共同构建现代化 web 应用的技术手段及方法策略。

**微前端呢，是将一个前端应用拆分成多个细粒度更小的微应用，这些微应用可以独立开发、测试、部署，且互不影响。**

微前端架构，具有以下**四个核心价值**：
1. **技术栈无关**：不同的微应用可以选用不同的技术栈
2. **独立开发、测试、部署**：每一个微应用作为整体应用的独立一块，可以进行单独的开发、测试和部署，也就变得更易维护。
3. **增量升级**：微应用之间相互独立，在对整个应用进行重构升级时，可以逐个微应用地来升级（渐进式升级）
4. **独立运行时**：每个微应用之间状态隔离，运行时状态不共享

微前端的实现方法很多，比如 iframe、web Componets、组合应用路由分发……或者多种方法组合实现。

不管要怎么实现，**微前端的关键点在于三个：**
1. **微应用之间的切换**
2. **隔离（主应用和微应用之间、微应用和微应用之间）**
3. **通信（主应用和微应用之间、微应用和微应用之间）**


## 二、为什么大多微前端的实现不使用 iframe

iframe 能够提供绝对的隔离，但是它的最大的缺点就是在于它的隔离性无法突破：
1. DOM 结构的绝对隔离有一定的弊端。比如我在微应用里想弹出一个在全局的遮罩框，但因为 iframe 的 DOM 隔离性导致只能在 iframe 有一个遮罩
2. iframe 之间的通信只能通过 postMessage 或 contentWindow 对象来实现，过于局限不够灵活。
3. iframe 本身的性能问题。 比如它会阻塞 onload 事件影响主页加载。


## 三、qiankun 框架
阿里开源的一款基于 single-spa 的微前端框架，在 single-spa 的基础上做了拓展。

### 3.1 微应用的切换

#### 3.1.1 切换原理
采用路由分发策略，将不同的微应用与不同的路由关联起来，一旦浏览器的 url 发送变化，就会触发 路由匹配，匹配到的微应用就会被渲染到指定的 container 中。

路由匹配这部分功能，是基于 single-spa 的，qiankun 是在这基础上对微应用的渲染做了拓展，具体体现在 js 和 css 的隔离上。

#### 3.1.2 切换流程
1. url 改变，触发路由匹配，旧的微应用被卸载，准备渲染匹配到的新微应用
2. 执行新微应用的 start 方法，最终会执行它的 loadApp 方法
3. loadApp 执行过程：
	1. 调用 import-html-entry 库的 importEntry 方法来下载微应用的静态资源
		- 下载 template 模板字符串
		- 解析 template 字符串：
			+ 下载 link css 文件，转换 style 标签样式
			+ 封装一个 execScripts 方法，用来下载和解析 script 脚本 
	2. 用 template 来创建 DOM 对象，并插入到页面中
		- 可以通过创建 shadow DOM 来实现 css 隔离
	3. 创建 js 沙箱，得到微应用的 window 代理 → global
	4. 用 global 去执行 execScripts 来下载解析微应用的 script 脚本
		- 套一个立即执行函数：`function(window){ ... js脚本 }(global)`，让微应用访问的 window 变为 global
4. js 线程为空，GUI 线程渲染微应用

### 3.2 隔离
分 js 隔离 和 css 隔离，js 隔离也叫 js 沙箱。

### 3.2.1 JsSandbox（js 沙箱）

分支持 proxy 和不支持 proxy 两类，而支持 proxy 的，也有两种实现：

```typescript
// qiankun 源码 → 创建微应用的沙箱 → 维护主应用和微应用之间的 window 隔离
export function createSandboxContainer(
  appName: string,
  elementGetter: () => HTMLElement | ShadowRoot,
  scopedCSS: boolean,
  useLooseSandbox?: boolean,
  excludeAssetFilter?: (url: string) => boolean,
) {
  let sandbox: SandBox;
  // 创建沙箱
  if (window.Proxy) {
    // 支持 proxy
    sandbox = useLooseSandbox ? new LegacySandbox(appName) : new ProxySandbox(appName);
  } else {
    // 不支持 proxy
    sandbox = new SnapshotSandbox(appName);
  }
  ...
  return {
    instance: sandbox,
    async mount() {
        sandbox.active(); // 唤醒微应用的 js 沙箱
        ...
    },
    // 微应用在 mount → unmount 周期内，访问和修改 window
    async unmount() {
        ...
        sandbox.inactive(); // 恢复 window 状态，使其能回到微应用加载之前的状态
    },
  }
}

```
一共有三种实现：
1. legacySandBox：仅用于单实例模式，也就是同一时间只加载一个微应用
2. proxySandBox：适用多实例模式，可以同一时间加载多个微应用（qiankun 最完备的沙箱模式）
3. SnapshotSandbox：对于不支持 proxy 的低版本浏览器的兼容

legacySandBox 和 proxySandBox 模式下，都会创建一个 proxy 代理。二者**创建 proxy 代理的目的都是拦截微应用对 window 的基本操作**。那么，它是怎么拦截的呢？看如下代码：
```js
// 微应用脚本文件的执行过程：
eval(
  // 这里将 proxy 作为 window 参数传入
  // 微应用的全局对象就是该子应用沙箱的 proxy 对象
  (function(window) {
    /* 微应用脚本文件内容 */
  })(proxy)
);
```

#### 1. legacySandBox
legacySandBox 会创建一个空的 fakeWindow 对象，给这个 fakeWindow 空对象创建 proxy 代理，proxy 代理会拦截到微应用的对 window 的基本操作，并以此**维护去三个状态池，分别用来还原主应用和子应用**：
1. 在子应用卸载时，还原主应用
2. 在子应用加载，还原子应用

用到三个状态池分别是：
1. addedPropsMapInSandbox：存储子应用运行时**新增的全局变量**，子应用卸载时用它来**还原主应用**
2. modifiedPropsOriginalValueMapInSandbox：存储子应用运行时**修改的全局变量**，子应用卸载时用它来**还原主应用**
3. currentUpdatedPropsValueMap：存储子应用卸载前的**最新全局变量**，但子应用被重新加载时用它来**还原子应用**

总结：**本质还是在 window 上进行修改，不过用三个变量去保存了子应用加载前、卸载后的 window，前者用以子应用卸载时还原 window，后者用于子应用下次加载时还原 window**。

#### 2. proxySandBox
proxySandBox 会**将 window 上的属性复制一份到 fakeWindow 对象上**，然后给 fakeWindow 创建一个 proxy 代理，proxy 代理会拦截到微应用的对 window 的基本操作，这些**基本操作大部分只会影响到 fakeWindow 对象而不会影响到真正的 window 对象。**

**比起 legacySandBox，proxySandBox 的隔离性明显更好，因为 legacySandBox 本质还是在 window 上操作，而 proxySandBox 则是真正地隔离了 window。**

#### 3. snapshotSandBox
对于不支持 proxy 的浏览器的兼容实现，思路很简单：
1. 微应用加载 → 用 windowSnapshot 记录主应用 window，再用 modifyPropsMap 还原微应用 window 
2. 微应用卸载 → 用 modifyPropsMap 记录微应用window，再用 windowSnapshot 还原主应用 window

snapshot，快照，顾名思义，给微应用加载和卸载时的 window 留一个快照，用于还原。


#### 4. 其他
三种 js 沙箱都是对 window 上的属性进行了隔离，而沙箱除了属性隔离，还有其他的一些重要东西需要隔离，比如计时器、事件、history 事件……

这些其实都在沙箱的 mount 钩子里的这句代码里：
```js
// render 沙箱启动时开始劫持各类全局监听，尽量不要在应用初始化阶段有 事件监听/定时器 等副作用
mountingFreers = patchAtMounting(appName, elementGetter, sandbox, scopedCSS, excludeAssetFilter);
```

以后有时间再研究。。。


### 3.2.1 css 隔离
qiankun 的 css 隔离方案有两种：
1. 加载一个微应用时，给微应用DOM 外部套一个 shadow DOM
2. 给微应用的 css 添加特定前缀（猜测）

在实际开发中，也有一些其他的办法，比如：
1. 约定式编程，给 css 的编写定义一定的约束。比如不同的微应用使用不同的 class 前缀。
2. css in js，比如 vue 里的 scope style。

> 什么是 shadow DOM ？类似 video 标签，它其实就是一个 shadow DOM。shadow DOM 内部有自己的 DOM 结构，且外部无法通过 js 访问，外部的 css 对其也无效。
> 
> 因此，shadow DOM 可以作为微应用的 css 隔离容器。


### 3.3 通信
#### 3.3.1 Actions 通信
qiankun 的 Actions 通信采取的是观察者模式。

在主应用和微应用之间维护一个 globalState，然后在主应用或微应用里通过 onGlobalStateChange 注册了观察者回调，当主/微应用使用 setGlobalState api 修改 globalState 时，就会触发观察者池里的全部观察者。

观察者可以通过 offGlobalStateChange 卸载。

![](https://user-gold-cdn.xitu.io/2020/5/8/171f3c48e01117fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 3.3.2 Shared 通信方案
采用 Actions 通信方式的微应用在独立运行时，需要额外配置无 Actions 的逻辑。如果希望子应用具备完全独立运行能力，可以采用 Shared 通信方式。

Shared 通信方案的原理：

主应用基于 redux 维护一个状态池，通过 shared 实例暴露一些方法给子应用使用。

同时，子应用需要单独维护一份 shared 实例，在独立运行时使用自身的 shared 实例，在嵌入主应用时使用主应用的 shared 实例，这样就可以保证在使用和表现上的一致性。








