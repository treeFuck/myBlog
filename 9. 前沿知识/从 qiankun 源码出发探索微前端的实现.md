# 探索微前端——从 qiankun 实现原理出发

## 一、前言

先说一下背景。在最初了解到组内业务的是时候，我发现公众号的 mp 系统是 MPA 模式，而不是我之前接触比较多的 SPA 模式，当然，这里面有很多历史原因，我就不细说了（其实是因为我暂时也不太了解）。

然后，我开始思考一个问题，如果要把公众号 mp 系统迁移为 SPA 的话，是否可行？

首先，如果是纯粹地使用一个  SPA 框架（比如 vue）去改写整个系统的话，无疑是不可行的，工程量巨大不说，迁移后的收益也不高，项目整体的维护难度也会几何倍提升。

那么，有没有一种比较合适的方案去将 MPA 改写为 SPA 呢？然后我想到了它——微前端。

什么是微前端呢？微前端这个概念其实脱胎于 “微服务”，旨在将一个大型的应用拆分成多个独立的微应用，这些微应用可以拥有独立的开发、测试、部署的能力。

而基于这个特性，我们可以拓展出更多与传统 SPA 不一样的开发场景：

1. **技术栈无关**
   
	> 这个是微前端最吸引人心的一个特性。每一个微应用相互独立互不干扰，所以它们完全可以使用不同的技术栈进行开发，这也更方便了跨技术栈的多团队合作。

2. **独立开发、测试、部署**

   > 微应用作为一个独立的单位，它具有独立的开发、测试、部署能力。举个例子，对于传统的 SPA 应用，我们每一次部署前可能都需要对整个项目进行打包构建，如果项目过大，这个构建耗时可能会十分离谱。但在微前端的架构下，微应用的打包构建是可以并行执行的，大大节省整体耗时。


3. **增量式升级**

   > 如果我们需要对一个项目进行技术栈升级，在微应用的框架下，我们可以不用对项目进行一次性的全面升级，而是可以选择对微应用进行逐个升级。


说了那么多概念的东西，可能你也听得晕晕乎乎的，还是来点硬货吧。我们来看一下微前端的杰出代表 —— qiankun 同学。

## 二、qiankun 的使用

qiankun 是阿里开源的一个微前端框架，据说已在蚂蚁内部服务了超过 200+ 线上应用，属于微前端架构里比较有代表性的一个产品。

qiankun 将应用分为两种：主应用和微应用。主应用是基层应用，用以管理各个微应用，而微应用则是我们对大型应用进行解耦后的一个独立单位，可以进行独立的开发、测试、部署。

那么 qiankun 要怎么使用呢？

首先，我们需要在主应用里注册微应用：

```js
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'react app', // 微应用的代称
    entry: '//localhost:7100', // 拉取微应用资源的 url
    container: '#yourContainer', // 挂载微应用的 DOM 节点
    activeRule: '/yourActiveRule', // 微应用的路由路径
  }
]);

start();
```

看完微应用的注册，你可能已经猜到 qiankun 是怎么管理微应用的了——没错，依旧是**路由策略**。

qiankun 对于微应用的管理其实是基于 **single-spa**（另一个微前端框架）的，single-spa 创建了一份路由到微应用的映射表，所以我们能够通过修改 url 来触发路由匹配，匹配到当前路由路径 activeRule 对应的微应用。

但在 single-spa 里，并没有实现获取微应用资源的功能，而是把这部分功能开放出来留给开发者自己去实现。还好，qiankun 帮我们实现了这部分功能。它怎么实现呢，其实还是调库，调了一个叫 **import-html-entry** 库的去拉取微应用的资源，拉取的 url 地址就是注册微应用时指明的 entry 字段。

拉取到微应用资源后，qiankun 就会把拉取到微应用资源挂载到 container 字段里指明的 DOM 节点上。

![](https://ftp.bmp.ovh/imgs/2021/04/4b27183e7b51a00d.png)

## 三、qiankun 的隔离

可以说，single-spa 和 import-html-entry 构建起了 qiankun 的一个整体架构，实现了主应用和微应用的整体管理。

而 qiankun 真正核心的部分，在于它实现的**隔离性**。

什么叫隔离呢？我们想一下，主应用加载了一个微应用，但这二者其实在 DOM 结构上是属于同一份 html 的，如果二者的 css 规则发生了冲突怎么办？更关键的是，二者的 js 逻辑也是运行在同一个 GO 对象下的，如果发生了变量定义的冲突怎么办？

所以这个时候，我们需要对微应用进行一个隔离，包括它的 css 隔离和 js 隔离。

css 隔离怎么实现的呢，qiankun 里面提供一个策略是——在微应用的外部套一层 shadow DOM。这时微应用就作为一个隐藏的、独立的 DOM 树挂载在 html 上，不会受到主应用 css 的污染。

js 隔离怎么实现呢，qiankun 会给微应用创建一个封闭的 js 沙箱，用以执行它的 js 脚本，进而实现 js 的隔离。**首先，qiankun 会对 window 进行深复制，然后得到一个克隆对象 global，再然后通过 proxy 代理去拦截微应用对于 window 的操作，将这些操作全部指向到 global 上。具体怎么拦截呢，其实是将微应用的 js 脚本都套在一个立即执行函数上面：**
```js
// 创建微应用的 js 沙箱
let proxy = new ProxySandbox(appName);
...
// 执行微应用的 js 脚本
(function(window) {
	console.log(window);
	// 微应用 js 脚本里访问到的 window，就不是真实 window，而是被 qiankun 创建出来的 js 沙箱
})(proxy);
```
![](https://ftp.bmp.ovh/imgs/2021/04/5801b22096d6347a.png)

当然，这种隔离不是绝对性的，还是有办法进行突破的。比如，我在 js 脚本里直接这样使用一个没有声明过的变量 a：
```js
a = 99;
```
这种写法在严格模式下会报错，但是在非严格模式下，这句代码就会直接对真实 window 对象下的变量 a 进行读写，也就突破了我们给该微应用创建的 js 沙箱环境。

## 四、qiankun 的通信

解决完隔离问题，接下来我们就得解决通信问题了。在 qiankun 里，微应用与微应用，或者微应用与主应用是怎么进行通信的呢？

qiankun 提供一种基于观察者模式的通信机制—— Actions 通信。

首先，我们需要调用 initGlobalState 方法，来注册一个 MicroAppStateActions 实例。这个实例有三个方法，分别是：

+ setGlobalState：设置 globalState 的值，触发通知，通知到所有的观察者函数。
+ onGlobalStateChange：注册观察者函数，响应 globalState 变化。
+ offGlobalStateChange：注销观察者函数，该实例不再响应 globalState 变化。

另外，qiankun 还提供一种基于 redux 的 Shared 通信方案，有兴趣的同学可以自行去了解（因为俺不是很了解）。

## 五、关于微前端的思考

微前端，本身是一种 SPA 模式的架构理念，在拥有 SPA 的诸多好处的同时，它也可以最大程度地去复现 MPA 模式下页面与页面之间天然的独立性，无疑是一种很适合开发大型 SPA 的架构方式。

另外，微前端本身只是一个架构理念，并没有一种明文规定的实现方式，不同的团队都可以用贴合自身业务的方式去搭建自己的微前端环境。举个例子，美团外卖团队的组内的技术栈都是 React，并没有 “跨技术栈” 的一个需求，所以他们直接选择了和 React 生态贴合的 React-Router 来实现微应用的路由管理，以及选择 Redux 来实现微应用的通信，大大降低了他们搭建微前端环境的一个成本。具体可以参考下面这个博客：

[微前端在美团外卖的实践]:https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html



